[{"path":"index.html","id":"section","chapter":"","heading":"","text":"","code":""},{"path":"index.html","id":"dịch-tễ-học-ứng-dụng-và-y-tế-công-cộng-với-r","chapter":"","heading":"Dịch tễ học ứng dụng và y tế công cộng với R","text":"Sổ tay này hướng tới:Là một tài liệu tham khảo R một cách nhanh chóngCung cấp các ví dụ tập trung vào nhiệm vụ giải quyết các vấn đề dịch tễ học phổ biếnHỗ trợ các nhà dịch tễ học chuyển sang sử dụng RCó thể sử dụng trong các tình huống có kết nối internet thấp thông qua [phiên bản ngoại tuyến][Tải sách và dữ liệu]Ngôn ngữ: English  Được viết bởi các nhà dịch tễ học, dành cho các nhà dịch tễ họcApplied Epi là một tổ chức phi lợi nhuận và phong trào cơ sở của các nhà dịch tễ học từ khắp mọi nơi trên thế giới. Chúng tôi dành thời gian rảnh rỗi của mình để viết và cung cấp tài nguyên này cho cộng đồng. Mọi lời động viên khuyến khích và phản hồi của bạn đều được chúng tôi chào đón:Gửi biểu mẫu phản hồiEmail tới epiRhandbook@gmail.com hoặc tweet @epiRhandbookGửi các vấn đề cho chúng tôi tại Github repository","code":""},{"path":"index.html","id":"sổ-tay-này-được-sử-dụng-như-thế-nào","chapter":"","heading":"Sổ tay này được sử dụng như thế nào","text":"Truy cập các trang trong phần Mục lục, hoặc sử dụng ô tìm kiếmNhấn biểu tượng “copy” để sao chép codeKết hợp theo dõi cùng với các bộ [dữ liệu minh họa][Tải sách và dữ liệu]Xem phần “Tài nguyên” trong từng chương để tìm thêm tài liệuPhiên bản ngoại tuyếnXem hướng dẫn tại trang [Tải sách và dữ liệu].","code":""},{"path":"index.html","id":"lời-cảm-ơn","chapter":"","heading":"Lời cảm ơn","text":"Sổ tay này được tạo ra bởi sự hợp tác của các nhà dịch tễ học từ khắp nơi trên thế giới, đúc kết kinh nghiệm cùng với các tổ chức khác bao gồm các cơ quan y tế địa phương, tiểu bang, tỉnh và quốc gia, Tổ chức Y tế Thế giới (), Tổ chức Bác sỹ không biên giới (MSF), hệ thống các bệnh viện, và các đơn vị nghiên cứu.Sổ tay này không phải là sản phẩm đã được phê duyệt của bất kỳ tổ chức cụ thể nào. Mặc dù chúng tôi cố gắng đảm bảo tính chính xác, nhưng chúng tôi không chịu trách nhiệm về nội dung trong cuốn sách này.","code":""},{"path":"index.html","id":"những-người-đóng-góp","chapter":"","heading":"Những người đóng góp","text":"Chủ biên: Neale BatraNhóm tác giả: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen LinNhóm dịch giả: Nguyễn Thanh Lương, Nguyễn Thị Khánh Huyền, Võ Hữu Thuận, Nguyễn Trung Thành, Vũ Thu Hà, Hồ Hoàng DungNhóm phản biện: Pat Keating, Amrish Baidjoe, Annick Lenglet, Margot Charette, Danielly Xavier, Marie-Amélie Degail Chabrat, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao MuiangaHình minh họa: Calder Fong","code":""},{"path":"index.html","id":"tài-trợ-và-hỗ-trợ","chapter":"","heading":"Tài trợ và hỗ trợ","text":"Sổ tay này nhận được tài trợ thông qua kinh phí hỗ trợ trợ xây dựng năng lực khẩn cấp COVID-19 từ TEPHINET, mạng lưới toàn cầu của các Chương trình Đào tạo Dịch tễ học Thực địa (FETPs).Các hỗ trợ hành chính được cung cấp bởi mạng lưới cựu sinh EPIET (EAN), với lời cảm ơn đặc biệt tới Annika Wendland. EPIET là Chương trình đào tạo Dịch tễ học can thiệp tại Châu Âu.Đặc biệt gửi lời cảm ơn tới Trung tâm Điều hành Amsterdam (OCA) của Tổ chức Bác sỹ không biên giới (MSF) cho những sự hỗ trợ của họ trong quá trình phát triển cuốn sổ tay này.Ấn phẩm này được hỗ trợ bởi Hợp đồng Hợp tác số NU2GGH001873, được tài trợ bởi Trung tâm Kiểm soát và Phòng ngừa Dịch bệnh thông qua TEPHINET, một chương trình của Lực lượng đặc nhiệm về sức khỏe toàn cầu. Nội dung của sổ tay hoàn toàn tác giả chịu trách nhiệm và đại diện cho quan điểm chính thức của Trung tâm Kiểm soát và Phòng ngừa Dịch bệnh, Bộ Y tế và Dịch vụ Nhân sinh, Lực lượng Đặc nhiệm về Sức khỏe Toàn cầu, hoặc TEPHINET","code":""},{"path":"index.html","id":"cảm-hứng","chapter":"","heading":"Cảm hứng","text":"Rất nhiều các hướng dẫn và tóm tắt cung cấp kiến thức sử dụng để phát triển nội dung sổ tay này được tham khảo trong các trang nội dung tương ứng.Một cách tổng quát hơn, các nguồn sau đây đã truyền nguồn cảm hứng cho cuốn sổ tay này:“R4Epis” project (một sự hợp tác giữa MSF và RECON)R Epidemics Consortium (RECON)R Data Science book (R4DS)bookdown: Authoring Books Technical Documents R MarkdownNetlify để lưu trữ trang web này","code":""},{"path":"index.html","id":"điều-khoản-sử-dụng-và-đóng-góp","chapter":"","heading":"Điều khoản sử dụng và đóng góp","text":"","code":""},{"path":"index.html","id":"giấy-phép","chapter":"","heading":"Giấy phép","text":"Sổ tay này được cấp phép theo Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.Chúng tôi khuyến khích các khóa học và các chương trình đào tạo dịch tễ sử dụng cuốn sổ tay này cho sinh viên của mình. Nếu bạn có thắc mắc về mục đích sử dụng của mình, hãy gửi email tới epiRhandbook@gmail.com.","code":""},{"path":"index.html","id":"trích-dẫn","chapter":"","heading":"Trích dẫn","text":"Neale Batra và cộng sự, Cẩm nang Dịch tễ học với R. ","code":""},{"path":"index.html","id":"đóng-góp","chapter":"","heading":"Đóng góp","text":"Nếu bạn muốn đóng góp nội dung, vui lòng liên hệ với chúng tôi thông qua Github hoặc email. Chúng tôi đang triển khai lịch trình cập nhật cho cuốn sách cũng như xây dựng hướng dẫn dành cho cộng tác viên.Xin lưu ý rằng dự án epiRhandbook được phát hành cùng với bộ Quy tắc ứng xử của cộng tác viên. Bằng cách đóng góp cho dự án này, bạn đồng ý tuân theo các điều khoản của nó.","code":""},{"path":"gis.html","id":"gis","chapter":"1 GIS cơ bản","heading":"1 GIS cơ bản","text":"","code":""},{"path":"gis.html","id":"tổng-quan","chapter":"1 GIS cơ bản","heading":"1.1 Tổng quan","text":"Các khía cạnh không gian trong dữ liệu của bạn có thể cung cấp nhiều thông tin chi tiết về tình hình đợt bùng phát dịch và để trả lời các câu hỏi như:Các điểm nóng về dịch bệnh hiện nay ở đâu?Các điểm nóng đã thay đổi như thế nào theo thời gian?Việc tiếp cận các cơ sở y tế như thế nào? Có cần thêm sự tăng cường nào không?Trọng tâm hiện tại trong chương GIS này nhằm giải quyết nhu cầu của các nhà dịch tễ học ứng dụng trong ứng phó với các đợt bùng phát dịch. Chúng ta sẽ khám phá các phương pháp trực quan hóa dữ liệu không gian cơ bản bằng cách sử dụng package tmap và ggplot2. Chúng ta cũng sẽ đi qua một số phương pháp quản lý và truy vấn dữ liệu không gian cơ bản với package sf. Cuối cùng, chúng ta sẽ đề cập ngắn gọn đến các khái niệm về thống kê không gian (spatial statistics) như mối quan hệ không gian, tự tương quan không gian và hồi quy không gian bằng cách sử dụng package spdep.","code":""},{"path":"gis.html","id":"các-thuật-ngữ-chính","chapter":"1 GIS cơ bản","heading":"1.2 Các thuật ngữ chính","text":"Dưới đây chúng tôi giới thiệu một số thuật ngữ chính. Để được giới thiệu kỹ lưỡng về GIS và phân tích không gian, chúng tôi khuyên bạn nên xem lại một trong các hướng dẫn hoặc khóa học dài hơn được liệt kê trong phần Tài nguyên học liệu.Hệ thống thông tin địa lý (Geographic Information System - GIS) - GIS là một framework hoặc môi trường để thu thập, quản lý, phân tích và trực quan hóa dữ liệu không gian.","code":""},{"path":"gis.html","id":"phần-mềm-gis","chapter":"1 GIS cơ bản","heading":"Phần mềm GIS","text":"Một số phần mềm GIS phổ biến cho phép tương tác bằng các thao tác chuột để phát triển bản đồ và phân tích không gian. Những công cụ này đi kèm với những lợi thế như không cần phải học code và dễ dàng lựa chọn và đặt các biểu tượng và tính năng trên bản đồ theo cách thủ công. Dưới đây là hai phần mềm phổ biến:ArcGIS - Một phần mềm GIS thương mại công ty ESRI phát triển, rất phổ biến nhưng khá đắtQGIS - Một phần mềm GIS mã nguồn mở nhưng làm được hầu hết mọi thứ mà ArcGIS có thể làm được. Bạn có thể tải QGIS tại đâySử dụng R để thao tác GIS thoạt đầu có vẻ đáng sợ hơn bởi vì thay bằng các “thao tác chuột”, nó có “giao diện dòng lệnh” (bạn phải viết code để có được kết quả mong muốn). Tuy nhiên, đây là một lợi thế lớn nếu bạn cần tạo bản đồ lặp đi lặp lại hoặc tạo các phân tích có thể tái lập được.","code":""},{"path":"gis.html","id":"dữ-liệu-không-gian","chapter":"1 GIS cơ bản","heading":"Dữ liệu không gian","text":"Hai dạng dữ liệu không gian chính được sử dụng trong GIS là dữ liệu vectơ và raster:Vector Data - Định dạng phổ biến nhất của dữ liệu không gian được sử dụng trong GIS, dữ liệu vectơ bao gồm các đặc điểm hình học của vertices paths. Dữ liệu không gian dạng vectơ có thể được chia thành ba loại nhỏ được sử dụng rộng rãi:Điểm (Points) - Một điểm bao gồm một cặp tọa độ (x, y) đại diện cho một vị trí cụ thể trong một hệ tọa độ. Điểm là dạng dữ liệu không gian cơ bản nhất và có thể được sử dụng để biểu thị một trường hợp (vd: nhà bệnh nhân) hoặc một vị trí (vd: bệnh viện) trên bản đồ.Điểm (Points) - Một điểm bao gồm một cặp tọa độ (x, y) đại diện cho một vị trí cụ thể trong một hệ tọa độ. Điểm là dạng dữ liệu không gian cơ bản nhất và có thể được sử dụng để biểu thị một trường hợp (vd: nhà bệnh nhân) hoặc một vị trí (vd: bệnh viện) trên bản đồ.Đường (Lines) - Một đường bao gồm hai điểm kết nối với nhau. Đường có độ dài và có thể được sử dụng để biểu thị những thứ như con đường hoặc sông.Đường (Lines) - Một đường bao gồm hai điểm kết nối với nhau. Đường có độ dài và có thể được sử dụng để biểu thị những thứ như con đường hoặc sông.Đa giác (Polygons) - polygon composed least three line segments connected points. Polygon features length (.e. perimeter area) well area measurement. Polygons may used note area (.e. village) structure (.e. actual area hospital).Đa giác (Polygons) - polygon composed least three line segments connected points. Polygon features length (.e. perimeter area) well area measurement. Polygons may used note area (.e. village) structure (.e. actual area hospital).Raster Data - Một đa giác bao gồm ít nhất ba đoạn thẳng được nối với nhau bằng các điểm. Các đối tượng đa giác có chiều dài (vd: chu vi của khu vực) cũng như số đo diện tích. Đa giác có thể được sử dụng để biểu diễn một khu vực (vd: một ngôi làng) hoặc một cấu trúc (vd: diện tích thực tế của một bệnh viện).","code":""},{"path":"gis.html","id":"trực-quan-hóa-dữ-liệu-không-gian","chapter":"1 GIS cơ bản","heading":"Trực quan hóa dữ liệu không gian","text":"Để thể hiện trực quan dữ liệu không gian trên bản đồ, phần mềm GIS yêu cầu bạn cung cấp đầy đủ thông tin về vị trí của các đối tượng địa lý khác nhau, trong mối quan hệ của chúng với nhau. Nếu bạn đang sử dụng dữ liệu vectơ, điều này sẽ đúng cho hầu hết các trường hợp sử dụng, thông tin này thường sẽ được lưu trữ trong một shapefile:Shapefiles - Shapefile là một định dạng dữ liệu phổ biến để lưu trữ dữ liệu không gian “vectơ” bao gồm hoặc đường, điểm hoặc đa giác. Một shapefile thực chất là một tập hợp của ít nhất ba tệp - .shp, .shx và .dbf. Tất cả các tệp thành phần phụ này phải nằm trong cùng một thư mục để chúng có thể đọc được. Các tệp liên quan này có thể được nén vào một thư mục ZIP để gửi qua email hoặc tải xuống từ một trang web.Shapefile sẽ chứa thông tin về bản thân các đối tượng địa lý cũng như vị trí định vị chúng trên bề mặt Trái đất. Điều này rất quan trọng bởi vì trong khi Trái đất là một quả địa cầu, các bản đồ thường là hai chiều; các lựa chọn về cách “làm phẳng” dữ liệu không gian có thể có tác động lớn đến giao diện và cách giải thích các kết quả..Hệ trục tọa độ tham chiếu (Coordinate Reference Systems - CRS) - CRS là một hệ thống dựa trên tọa độ được sử dụng để xác định vị trí các đối tượng địa lý trên bề mặt Trái đất. Nó có một số thành phần chính:Hệ tọa độ - Có nhiều hệ tọa độ khác nhau, vì vậy hãy đảm bảo rằng bạn biết hệ tọa độ của mình là từ hệ nào. Các kinh độ/vĩ độ là phổ biến nhẩt, nhưng bạn cũng có thể gặp hệ tọa độ UTM.Hệ tọa độ - Có nhiều hệ tọa độ khác nhau, vì vậy hãy đảm bảo rằng bạn biết hệ tọa độ của mình là từ hệ nào. Các kinh độ/vĩ độ là phổ biến nhẩt, nhưng bạn cũng có thể gặp hệ tọa độ UTM.Đơn vị - Các đơn vị dành cho hệ tọa độ của bạn (ví dụ: độ thập phân, mét)Đơn vị - Các đơn vị dành cho hệ tọa độ của bạn (ví dụ: độ thập phân, mét)Dữ liệu - Một phiên bản được mô hình hóa cụ thể của Trái đất. Chúng đã được sửa đổi trong nhiều năm, vì vậy hãy đảm bảo rằng các lớp bản đồ của bạn đang sử dụng cùng một dữ liệu..Dữ liệu - Một phiên bản được mô hình hóa cụ thể của Trái đất. Chúng đã được sửa đổi trong nhiều năm, vì vậy hãy đảm bảo rằng các lớp bản đồ của bạn đang sử dụng cùng một dữ liệu..Phép chiếu - Tham chiếu đến phương trình toán học được sử dụng để chiếu trái đất hình tròn lên một bề mặt phẳng (bản đồ).Phép chiếu - Tham chiếu đến phương trình toán học được sử dụng để chiếu trái đất hình tròn lên một bề mặt phẳng (bản đồ).Hãy nhớ rằng bạn có thể tóm tắt dữ liệu không gian mà không cần sử dụng các công cụ lập bản đồ được hiển thị bên dưới. Đôi khi một bảng đơn giản phân chia theo địa lý (ví dụ: huyện, quốc gia, v.v.) là tất cả những gì cần thiết!","code":""},{"path":"gis.html","id":"bắt-đầu-với-gis","chapter":"1 GIS cơ bản","heading":"1.3 Bắt đầu với GIS","text":"Có một số thứ quan trọng bạn sẽ cần phải có và suy nghĩ tới khi tạo bản đồ. Bao gồm:Một tập dữ liệu – tập dữ liệu này có thể ở định dạng dữ liệu không gian (chẳng hạn như shapefiles, như đã lưu ý ở trên) hoặc nó có thể không ở định dạng không gian (chẳng hạn như csv).Một tập dữ liệu – tập dữ liệu này có thể ở định dạng dữ liệu không gian (chẳng hạn như shapefiles, như đã lưu ý ở trên) hoặc nó có thể không ở định dạng không gian (chẳng hạn như csv).Nếu tập dữ liệu của bạn không ở định dạng không gian, bạn cũng sẽ cần một tập dữ liệu tham chiếu. Dữ liệu tham chiếu bao gồm biểu diễn không gian của dữ liệu và các thuộc tính liên quan, sẽ bao gồm tài liệu chứa thông tin vị trí và địa chỉ của các đối tượng địa lý cụ thể.\nNếu bạn đang làm việc với các ranh giới địa lý được xác định trước (ví dụ: khu vực hành chính), các shapefiles tham chiếu thường có sẵn miễn phí để tải xuống từ cơ quan chính phủ hoặc tổ chức chia sẻ dữ liệu. Khi nghi ngờ, bạn có thể tìm kiếm trên Google cụm từ “[tên vùng] shapefile”\nNếu bạn có thông tin địa chỉ, nhưng không có vĩ độ và kinh độ, bạn có thể cần sử dụng một công cụ mã hóa địa lý để lấy dữ liệu không gian tham chiếu cho bản ghi của mình.\nNếu tập dữ liệu của bạn không ở định dạng không gian, bạn cũng sẽ cần một tập dữ liệu tham chiếu. Dữ liệu tham chiếu bao gồm biểu diễn không gian của dữ liệu và các thuộc tính liên quan, sẽ bao gồm tài liệu chứa thông tin vị trí và địa chỉ của các đối tượng địa lý cụ thể.Nếu bạn đang làm việc với các ranh giới địa lý được xác định trước (ví dụ: khu vực hành chính), các shapefiles tham chiếu thường có sẵn miễn phí để tải xuống từ cơ quan chính phủ hoặc tổ chức chia sẻ dữ liệu. Khi nghi ngờ, bạn có thể tìm kiếm trên Google cụm từ “[tên vùng] shapefile”Nếu bạn đang làm việc với các ranh giới địa lý được xác định trước (ví dụ: khu vực hành chính), các shapefiles tham chiếu thường có sẵn miễn phí để tải xuống từ cơ quan chính phủ hoặc tổ chức chia sẻ dữ liệu. Khi nghi ngờ, bạn có thể tìm kiếm trên Google cụm từ “[tên vùng] shapefile”Nếu bạn có thông tin địa chỉ, nhưng không có vĩ độ và kinh độ, bạn có thể cần sử dụng một công cụ mã hóa địa lý để lấy dữ liệu không gian tham chiếu cho bản ghi của mình.Nếu bạn có thông tin địa chỉ, nhưng không có vĩ độ và kinh độ, bạn có thể cần sử dụng một công cụ mã hóa địa lý để lấy dữ liệu không gian tham chiếu cho bản ghi của mình.Ý tưởng về cách bạn muốn trình bày thông tin trong bộ dữ liệu của mình cho đối tượng mục tiêu. Có nhiều loại bản đồ khác nhau, và điều quan trọng là phải suy nghĩ xem loại bản đồ nào phù hợp nhất với nhu cầu của bạn.Ý tưởng về cách bạn muốn trình bày thông tin trong bộ dữ liệu của mình cho đối tượng mục tiêu. Có nhiều loại bản đồ khác nhau, và điều quan trọng là phải suy nghĩ xem loại bản đồ nào phù hợp nhất với nhu cầu của bạn.","code":""},{"path":"gis.html","id":"các-loại-bản-đồ-để-trực-quan-hóa-dữ-liệu","chapter":"1 GIS cơ bản","heading":"Các loại bản đồ để trực quan hóa dữ liệu","text":"Bản đồ Choropleth - một loại bản đồ trong đó màu sắc, sự đổ bóng, hoặc các họa tiết được sử dụng để thể hiện các vùng địa lý liên quan đến giá trị của một thuộc tính. Ví dụ: giá trị lớn hơn có thể được biểu thị bằng màu tối hơn giá trị nhỏ hơn. Loại bản đồ này đặc biệt hữu ích khi trực quan hóa một biến số và xem cách nó thay đổi trên các vùng hoặc khu vực địa chính trị xác định.Bản đồ nhiệt mật độ trường hợp - một loại bản đồ trong đó màu sắc được sử dụng để thể hiện cường độ của một giá trị, tuy nhiên, nó không sử dụng các vùng hoặc ranh giới địa chính trị xác định để nhóm dữ liệu. Loại bản đồ này thường được sử dụng để hiển thị ‘điểm nóng’ hoặc các khu vực có mật độ hoặc tập trung điểm cao.Bản đồ mật độ điểm - một loại bản đồ sử dụng các điểm để biểu thị các giá trị thuộc tính trong dữ liệu của bạn. Loại bản đồ này được sử dụng tốt nhất để trực quan hóa phân tán dữ liệu của bạn và scan một cách trực quan các cụm.Bản đồ ký hiệu tỷ lệ (bản đồ ký hiệu chia độ) - một loại bản đồ tương tự như bản đồ choropleth, nhưng thay vì sử dụng màu sắc để biểu thị giá trị của một thuộc tính, nó sử dụng một ký hiệu (thường là một vòng tròn) liên quan đến giá trị. Ví dụ, một giá trị lớn hơn có thể được biểu thị bằng một ký hiệu lớn hơn một giá trị nhỏ hơn. Loại bản đồ này được sử dụng tốt nhất khi bạn muốn trực quan hóa kích thước hoặc số lượng dữ liệu của mình trên các vùng địa lý.Bạn cũng có thể kết hợp một số loại trực quan hóa khác nhau để hiển thị các trường hợp địa lý phức tạp. Ví dụ, các trường hợp (điểm) trong bản đồ dưới đây được tô màu theo cơ sở y tế gần nhất của họ (xem phần chú thích). Các vòng tròn lớn hiển thị cơ sở y tế gần nhất trong khu vực ở một bán kính xác định, và các điểm màu đỏ tươi là những cơ sở y tế không nằm trong bất kỳ bán kính nào:Lưu ý: Trọng tâm chính trong chương GIS này được dựa trên tình huống đáp ứng các vụ dịch tại thực địa. đó, nội dung của chương sẽ bao gồm các thao tác, hình ảnh hóa và phân tích dữ liệu không gian cơ bản.","code":""},{"path":"gis.html","id":"chuẩn-bị","chapter":"1 GIS cơ bản","heading":"1.4 Chuẩn bị","text":"","code":""},{"path":"gis.html","id":"gọi-package","chapter":"1 GIS cơ bản","heading":"Gọi package","text":"Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương [R cơ bản] để có thêm thông tin về các packages trong R.Bạn có thể xem tổng quan về tất cả các package trong R xử lý dữ liệu không gian tại CRAN “Spatial Task View”.","code":"\npacman::p_load(\n  rio,           # to import data\n  here,          # to locate files\n  tidyverse,     # to clean, handle, and plot the data (includes ggplot2 package)\n  sf,            # to manage spatial data using a Simple Feature format\n  tmap,          # to produce simple maps, works for both interactive and static maps\n  janitor,       # to clean column names\n  OpenStreetMap, # to add OSM basemap in ggplot map\n  spdep          # spatial statistics\n  ) "},{"path":"gis.html","id":"dữ-liệu-trường-hợp-mẫu","chapter":"1 GIS cơ bản","heading":"Dữ liệu trường hợp mẫu","text":"Với mục đích minh họa, chúng ta sẽ làm việc với một mẫu ngẫu nhiên gồm 1000 trường hợp từ bộ dữ liệu một vụ dịch Ebola mô phỏng có tên linelist (về mặt tính toán, việc làm việc với ít trường hợp hơn sẽ dễ hiển thị hơn trong sổ tay này). Để tiện dõi, bấm để tải dữ liệu linelist “đã được làm sạch” (dưới dạng tệp .rds).Vì chúng ta đang lấy một mẫu ngẫu nhiên của các trường hợp, nên kết quả của bạn có thể hơi khác với những gì được minh họa ở đây khi bạn tự chạy code của mình.Nhập dữ liệu vào bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương [Nhập xuất dữ liệu] để biết thêm chi tiết).Tiếp theo, chúng ta chọn một mẫu ngẫu nhiên gồm 1000 hàng bằng hàm sample() từ base R.Bây giờ chúng ta muốn chuyển đổi bộ dữ liệu linelist đang là một dataframe, thành một đối tượng “sf” (spatial features - các đặc tính không gian). bộ dữ liệu linelist có hai cột “lon” và “lat” đại diện cho kinh độ và vĩ độ của nơi cư trú của từng trường hợp, nên việc chuyển đổi này khá dễ dàng.Chúng ta sử dụng package sf (spatial features - các đặc tính không gian) và hàm st_as_sf() của nó để tạo đối tượng mới có tên linelist_sf. Đối tượng mới này về cơ bản giống với linelist, nhưng các cột lon và lat đã được chỉ định là cột tọa độ, và một hệ thống tham chiếu tọa độ (CRS) đã được gán khi các điểm được hiển thị. 4326 xác định tọa độ của chúng ta dựa trên Hệ thống trắc địa thế giới 1984 (WGS84) - là tiêu chuẩn cho tọa độ GPS.Dưới đây là cách bộ dữ liệu linelist gốc được hiển thị. Trong phần minh họa này, chúng ta sẽ chỉ sử dụng cột date_onset và geometry (được xây dựng từ các trường kinh độ và vĩ độ ở trên và là cột cuối cùng trong khung dữ liệu).","code":"\n# import clean case linelist\nlinelist <- import(\"linelist_cleaned.rds\")  \n# generate 1000 random row numbers, from the number of rows in linelist\nsample_rows <- sample(nrow(linelist), 1000)\n\n# subset linelist to keep only the sample rows, and all columns\nlinelist <- linelist[sample_rows,]\n# Create sf object\nlinelist_sf <- linelist %>%\n     sf::st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326)\nDT::datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )"},{"path":"gis.html","id":"shapefiles-phân-cấp-hành-chính","chapter":"1 GIS cơ bản","heading":"Shapefiles phân cấp hành chính","text":"Sierra Leone: shapefiles phân cấp hành chínhTrước đó, chúng tôi đã tải xuống tất cả các phân cấp hành chính của Sierra Leone từ website của Humanitarian Data Exchange (HDX). Ngoài ra, bạn có thể tải xuống các dữ liệu này và tất cả các dữ liệu mẫu khác cho sổ tay này qua gói R của chúng tôi, như được giải thích trong trang [Tải sách và dữ liệu].Bây giờ chúng ta sẽ thực hiện những bước sau để lưu shapefile hành chính cấp 3 vào R:Nhập shapefileLàm sạch tên cộtLọc các hàng để chỉ giữ lại các khu vực quan tâmĐể nhập một shapefile, chúng ta sử dụng hàm read_sf() từ package sf. Nó được cung cấp đường dẫn tệp thông qua hàm (). - trong trường hợp này tệp nằm bên trong Dự án R của bạn tại thư mục “data”, rồi tới “gis”, và thư mục con “shp”, với tệp có tên “sle_adm3.shp” (xem chương [Nhập xuất dữ liệu] và [Dự án R] để biết thêm chi tiết). Bạn sẽ cần cung cấp đường dẫn tệp của riêng mình.Tiếp theo, chúng ta sử dụng hàm clean_names() từ package janitor để chuẩn hóa tên các cột của shapefile. Chúng ta cũng sử dụng hàm filter() để chỉ giữ lại các hàng có tên admin2 là “Western Area Urban” hoặc “Western Area Rural”.Dưới đây, bạn có thể thấy shapefile trông như thế nào sau khi nhập và làm sạch. Cuộn sang phải see columns hành chính cấp 0 (quốc gia), hành chính cấp 1, hành chính cấp 2, và cuối cùng là hành chính cấp 3. Mỗi cấp độ có một tên và một mã định danh duy nhất “pcode”. Pcode mở rộng với mỗi sự tăng lên của cấp hành chính, vd. SL (Sierra Leone) -> SL04 (Western) -> SL0410 (Western Area Rural) -> SL040101 (Koya Rural).","code":"\n# ADM3 level clean\nsle_adm3 <- sle_adm3_raw %>% \n  janitor::clean_names() %>% # standardize column names\n  filter(admin2name %in% c(\"Western Area Urban\", \"Western Area Rural\")) # filter to keep certain areas"},{"path":"gis.html","id":"dữ-liệu-dân-số","chapter":"1 GIS cơ bản","heading":"Dữ liệu dân số","text":"Sierra Leone: Dân số theo ADM3Những dữ liệu này có thể tải xuống từ HDX (link tại đây) hoặc thông qua R package epirhandbook như đã được giải thích [trong chương này][Tải sách và dữ liệu]. Chúng ta cũng sử dụng hàm import() để nạp tệp .csv. Chúng tôi cũng chuyển file được nhập tới hàm clean_names() để chuẩn hóa cú pháp tên cột.Bộ dữ liệu dân số trông sẽ như bên dưới. Cuộn sang bên phải để xem các cột: dân số nam (male population), dân số nữ (female populaton), tổng dân số (total population), và dân số theo từng nhóm tuổi.","code":"\n# Population by ADM3\nsle_adm3_pop <- import(here(\"data\", \"gis\", \"population\", \"sle_admpop_adm3_2020.csv\")) %>%\n  janitor::clean_names()"},{"path":"gis.html","id":"các-cơ-sở-y-tế","chapter":"1 GIS cơ bản","heading":"Các cơ sở y tế","text":"Sierra Leone: Dữ liệu cơ sở y tế từ OpenStreetMapMột lần nữa, bạn có thể tải xuống thông tin vị trí của các cơ sở y tế từ HDX tại đây hoặc thông qua hướng dẫn trong chương [Tải sách và dữ liệu].Chúng ta nhập shapefile tọa độ điểm các cơ sở với hàm read_sf(), làm sạch lại tên cột, sau đó lọc để chỉ giữ lại các điểm được gắn thẻ là “hospital”, “clinic”, hoặc “doctors”.Dưới đây là dataframe kết quả - Cuộn phải để xem tên cơ sở và tọa độ geometry.","code":"\n# OSM health facility shapefile\nsle_hf <- sf::read_sf(here(\"data\", \"gis\", \"shp\", \"sle_hf.shp\")) %>% \n  janitor::clean_names() %>%\n  filter(amenity %in% c(\"hospital\", \"clinic\", \"doctors\"))"},{"path":"gis.html","id":"vẽ-đồ-thị-tọa-độ","chapter":"1 GIS cơ bản","heading":"1.5 Vẽ đồ thị tọa độ","text":"Cách dễ nhất để vẽ đồ thị tọa độ X-Y (kinh độ / vĩ độ, điểm), trong trường hợp này, là vẽ chúng dưới dạng điểm trực tiếp từ đối tượng linelist_sf mà chúng ta đã tạo trong phần chuẩn bị.Package tmap cung cấp khả năng lập bản đồ đơn giản ở cả dạng tĩnh (“plot” mode) và tương tác (“view” mode) chỉ với một vài dòng code. Cú pháp của tmap tương tự như cú pháp của ggplot2, chẳng hạn như các lệnh được thêm vào nhau bằng dấu +. Đọc thêm chi tiết trong hướng dẫn này.Thiết lập tmap mode. Trong trường hợp này chúng ta sẽ sử dụng “plot” mode để tạo ra các biểu đồ tĩnh.Dưới đây, các điểm được vẽ độc lập. Hàm tm_shape() được cung cấp bởi đối tượng linelist_sf. Chúng ta sau đó thêm các điểm thông qua hàm tm_dots(), và cụ thể kích thước và màu sắc. linelist_sf là một đối tượng sf đã được chúng ta chỉ định hai cột chứa tọa độ vĩ độ/kinh độ và hệ quy chiếu tọa độ (CRS):Khi đứng một mình, các điểm không cho biết nhiều thông tin. Vì vậy, chúng ta nên lập bản đồ địa giới hành chính:Một lần nữa chúng ta sử dụng hàm tm_shape() (xem tài liệu này) nhưng thay vì cung cấp shapefile tọa độ điểm các trường hợp, chúng ta cung cấp shapefile địa giới hành chính (đa giác).Với đối số bbox = (bbox là viết tắt của “bounding box”), chúng ta có thể chỉ định các ranh giới tọa độ. Đầu tiên, chúng ta hiển thị bản đồ mà không có bbox, và sau đó thêm nó vào.Và bây giờ hiển thị các điểm và đa giác cùng nhau:Để đọc một bài sánh hay về các tùy chọn vẽ bản đồ trong R, hãy xem bài đăng blog này.","code":"\ntmap_mode(\"plot\") # choose either \"view\" or \"plot\"\n# Just the cases (points)\ntm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')\n# Just the administrative boundaries (polygons)\ntm_shape(sle_adm3) +               # admin boundaries shapefile\n  tm_polygons(col = \"#F7F7F7\")+    # show polygons in light grey\n  tm_borders(col = \"#000000\",      # show borders with color and line weight\n             lwd = 2) +\n  tm_text(\"admin3name\")            # column text to display for each polygon\n\n\n# Same as above, but with zoom from bounding box\ntm_shape(sle_adm3,\n         bbox = c(-13.3, 8.43,    # corner\n                  -13.2, 8.5)) +  # corner\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")\n# All together\ntm_shape(sle_adm3, bbox = c(-13.3, 8.43, -13.2, 8.5)) +     #\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")+\ntm_shape(linelist_sf) +\n  tm_dots(size=0.08, col='blue', alpha = 0.5) +\n  tm_layout(title = \"Distribution of Ebola cases\")   # give title to map"},{"path":"gis.html","id":"phép-nối-theo-không-gian","chapter":"1 GIS cơ bản","heading":"1.6 Phép nối theo không gian","text":"Bạn có thể đã quen với việc nối dữ liệu từ một tập dữ liệu này sang một tập dữ liệu khác. Một số phương pháp được thảo luận trong chương [Nối dữ liệu] của cuốn sổ tay này. Một phép nối theo không gian phục vụ một mục đích tương tự nhưng tận dụng các mối quan hệ không gian. Thay vì dựa vào các giá trị chung trong các cột để khớp chính xác các quan sát, bạn có thể sử dụng các mối quan hệ không gian của chúng, chẳng hạn như một đối tượng địa lý nằm trong đối tượng khác, hoặc hàng xóm gần nhất với đối tượng khác, hoặc ở trong vùng đệm của một bán kính nhất định từ đối tượng khác, v.v.Package sf cung cấp nhiều phương thức khác nhau để nối theo không gian. Xem thêm tài liệu về phương pháp st_join và các kiểu nối theo không gian trong tài liệu tham khảo này.","code":""},{"path":"gis.html","id":"điểm-trong-đa-giác","chapter":"1 GIS cơ bản","heading":"Điểm trong đa giác","text":"Gán đơn vị hành chính cho các trường hợp theo không gianSau đây là một câu hỏi hóc búa thú vị: linelist không chứa bất kỳ thông tin nào về các đơn vị hành chính của các trường hợp. Mặc dù lý tưởng nhất là thu thập thông tin như vậy trong giai đoạn thu thập dữ liệu ban đầu, chúng ta cũng có thể gán các đơn vị hành chính cho các trường hợp riêng lẻ dựa trên mối quan hệ không gian của chúng (tức là điểm giao với một đa giác)..Dưới đây, chúng ta sẽ giao các vị trí (điểm) theo không gian với địa giới hành chính cấp 3 (đa giác):Bắt đầu với linelist (các điểm)Nối theo không gian tới các địa giới, thiết lập kiểu nối là “st_intersects”Sử dụng hàm select() để chỉ giữ lại một số cột địa giới hành chính mớiTất cả các cột từ sle_adms đã được thêm vào linelist! Mỗi trường hợp bây giờ có các cột thể hiện chi tiết cấp hành chính mà nó nằm trong đó. Trong ví dụ này, chúng ta chỉ muốn giữ lại hai trong số các cột mới (địa giới hành chính cấp 3), vì vậy chúng dùng hàm select() để chọn tên các cột cũ và chỉ hai cột bổ sung quan tâm:Dưới đây, chỉ với mục đích hiển thị, bạn có thể thấy mười trường hợp đầu tiên và địa giới hành chính cấp 3 của chúng đã được gắn với nhau, dựa trên vị trí giao nhau trong không gian giữa các điểm với đa giác.Bây giờ chúng ta có thể mô tả các trường hợp theo đơn vị hành chính - điều mà chúng ta đã không thể làm trước khi nối theo không gian!Chúng ta cũng có thể tạo một biểu đồ cột về số lượng trường hợp theo đơn vị hành chính.Trong ví dụ này, chúng ta bắt đầu hàm ggplot() với bộ dữ liệu linelist_adm, trong đó chúng ta có thể áp dụng các hàm làm việc với factor như fct_infreq() để sắp xếp các cột theo tần suất (xem chương [Factors] để biết thêm các mẹo).","code":"\nlinelist_adm <- linelist_sf %>%\n  \n  # join the administrative boundary file to the linelist, based on spatial intersection\n  sf::st_join(sle_adm3, join = st_intersects)\nlinelist_adm <- linelist_sf %>%\n  \n  # join the administrative boundary file to the linelist, based on spatial intersection\n  sf::st_join(sle_adm3, join = st_intersects) %>% \n  \n  # Keep the old column names and two new admin ones of interest\n  select(names(linelist_sf), admin3name, admin3pcod)\n# Now you will see the ADM3 names attached to each case\nlinelist_adm %>% select(case_id, admin3name, admin3pcod)## Simple feature collection with 1000 features and 3 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: -13.27125 ymin: 8.448312 xmax: -13.20522 ymax: 8.490944\n## Geodetic CRS:  WGS 84\n## First 10 features:\n##      case_id     admin3name admin3pcod                   geometry\n## 2205  fc9869        West II   SL040207 POINT (-13.23306 8.466107)\n## 5416  619e1e        West II   SL040207 POINT (-13.23211 8.471123)\n## 945   81db03        East II   SL040204 POINT (-13.21548 8.477092)\n## 1809  09a0eb Mountain Rural   SL040102 POINT (-13.21269 8.465303)\n## 2729  eb8407        West II   SL040207  POINT (-13.2275 8.469608)\n## 3089  89006a       West III   SL040208 POINT (-13.26447 8.479505)\n## 2944  2d6a6a Mountain Rural   SL040102 POINT (-13.21929 8.475571)\n## 1262  72c803        West II   SL040207 POINT (-13.23632 8.467704)\n## 4609  bc9ace      Central I   SL040201 POINT (-13.22809 8.478953)\n## 2569  19db82 Mountain Rural   SL040102 POINT (-13.21175 8.449712)\n# Make new dataframe containing counts of cases by administrative unit\ncase_adm3 <- linelist_adm %>%          # begin with linelist with new admin cols\n  as_tibble() %>%                      # convert to tibble for better display\n  group_by(admin3pcod, admin3name) %>% # group by admin unit, both by name and pcode \n  summarise(cases = n()) %>%           # summarize and count rows\n  arrange(desc(cases))                 # arrange in descending order\n\ncase_adm3## # A tibble: 10 x 3\n## # Groups:   admin3pcod [10]\n##    admin3pcod admin3name     cases\n##    <chr>      <chr>          <int>\n##  1 SL040102   Mountain Rural   295\n##  2 SL040208   West III         234\n##  3 SL040207   West II          175\n##  4 SL040204   East II           99\n##  5 SL040203   East I            51\n##  6 SL040201   Central I         50\n##  7 SL040206   West I            50\n##  8 SL040202   Central II        21\n##  9 SL040205   East III          21\n## 10 <NA>       <NA>               4\nggplot(\n    data = linelist_adm,                       # begin with linelist containing admin unit info\n    mapping = aes(\n      x = fct_rev(fct_infreq(admin3name))))+ # x-axis is admin units, ordered by frequency (reversed)\n  geom_bar()+                                # create bars, height is number of rows\n  coord_flip()+                              # flip X and Y axes for easier reading of adm units\n  theme_classic()+                           # simplify background\n  labs(                                      # titles and labels\n    x = \"Admin level 3\",\n    y = \"Number of cases\",\n    title = \"Number of cases, by adminstative unit\",\n    caption = \"As determined by a spatial join, from 1000 randomly sampled cases from linelist\"\n  )"},{"path":"gis.html","id":"hàng-xóm-gần-nhất","chapter":"1 GIS cơ bản","heading":"Hàng xóm gần nhất","text":"Tìm cơ sở y tế gần nhất / khu vực cung cấp dịch vụ y tếCó thể sẽ hữu ích nếu biết các cơ sở y tế nằm ở đâu trong mối liên quan đến các điểm nóng về dịch bệnh.Chúng ta có thể sử dụng phương pháp nối st_nearest_feature trong hàm st_join() (sf package) để trực quan hóa cơ sở y tế gần nhất với các trường hợp bệnh nhân.Chúng ta bắt đầu với shapefile linelist có tên linelist_sfChúng ta nối theo không gian với đối tượng sle_hf, chứa thông tin về vị trí của các cơ sở y tế và phòng khám (các điểm)Chúng ta có thể thấy bên dưới (50 hàng đầu tiên) rằng mỗi trường hợp hiện đã có dữ liệu về phòng khám/bệnh viện gần nhấtChúng ta có thể thấy rằng “Den Clinic” là cơ sở y tế gần nhất với khoảng ~30% các trường hợp.Để trực quan hóa kết quả, chúng ta có thể sử dụng tmap - lúc này interactive mode sẽ xem dễ dàng hơn","code":"\n# Closest health facility to each case\nlinelist_sf_hf <- linelist_sf %>%                  # begin with linelist shapefile  \n  st_join(sle_hf, join = st_nearest_feature) %>%   # data from nearest clinic joined to case data \n  select(case_id, osm_id, name, amenity) %>%       # keep columns of interest, including id, name, type, and geometry of healthcare facility\n  rename(\"nearest_clinic\" = \"name\")                # re-name for clarity\n# Count cases by health facility\nhf_catchment <- linelist_sf_hf %>%   # begin with linelist including nearest clinic data\n  as.data.frame() %>%                # convert from shapefile to dataframe\n  count(nearest_clinic,              # count rows by \"name\" (of clinic)\n        name = \"case_n\") %>%         # assign new counts column as \"case_n\"\n  arrange(desc(case_n))              # arrange in descending order\n\nhf_catchment                         # print to console##                          nearest_clinic case_n\n## 1                            Den Clinic    362\n## 2       Shriners Hospitals for Children    362\n## 3         GINER HALL COMMUNITY HOSPITAL    160\n## 4                             panasonic     43\n## 5 Princess Christian Maternity Hospital     29\n## 6                     ARAB EGYPT CLINIC     20\n## 7                                  <NA>     13\n## 8                  MABELL HEALTH CENTER     11\ntmap_mode(\"view\")   # set tmap mode to interactive  \n\n# plot the cases and clinic points \ntm_shape(linelist_sf_hf) +            # plot cases\n  tm_dots(size=0.08,                  # cases colored by nearest clinic\n          col='nearest_clinic') +    \ntm_shape(sle_hf) +                    # plot clinic facilities in large black dots\n  tm_dots(size=0.3, col='black', alpha = 0.4) +      \n  tm_text(\"name\") +                   # overlay with name of facility\ntm_view(set.view = c(-13.2284, 8.4699, 13), # adjust zoom (center coords, zoom)\n        set.zoom.limits = c(13,14))+\ntm_layout(title = \"Cases, colored by nearest clinic\")"},{"path":"gis.html","id":"vùng-đệm","chapter":"1 GIS cơ bản","heading":"Vùng đệm","text":"Chúng ta cũng có thể tìm hiểu xem có bao nhiêu trường hợp nằm trong khoảng cách đi bộ 2,5 km (~30 phút) từ cơ sở y tế gần nhất.Chú ý: Để tính toán khoảng cách chính xác hơn, tốt hơn nên chiếu lại đối tượng sf của bạn lên hệ thống chiếu bản đồ địa phương tương ứng chẳng hạn như UTM (Trái đất được chiếu lên bề mặt phẳng). Trong ví dụ này, để đơn giản hơn, chúng ta sẽ dựa vào Hệ tọa độ địa lý của Hệ thống trắc địa thế giới (WGS84) (Trái đất được biểu diễn trong một bề mặt hình cầu/tròn, đó các đơn vị được tính bằng độ thập phân). Chúng ta sẽ sử dụng quy đổi chung là: 1 độ thập phân = ~111km.Xem thêm thông tin về phép chiếu bản đồ và hệ tọa độ tại bài viết này esri article. Blog này nói về các loại phép chiếu bản đồ khác nhau và cách người ta có thể chọn phép chiếu phù hợp tùy thuộc vào khu vực quan tâm và bối cảnh của bản đồ/phân tích của bạn.Đầu tiên, tạo một vùng đệm hình tròn với bán kính ~2.5km xung quanh mỗi cơ sở y tế. Điều này được thực hiện với hàm st_buffer() trong package tmap. Bởi vì đơn vị của bản đồ là kinh/vĩ độ thập phân, đó là cách “0.02” được diễn giải. Nếu hệ tọa độ bản đồ của bạn tính bằng mét, thì số đó phải được cung cấp bằng mét.Sau đây chúng ta vẽ biểu đồ của chính các vùng đệm, với:Thứ hai, chúng ta giao các vùng đệm này với các trường hợp (điểm) bằng cách sử dụng hàm st_join() và kiểu nối là st_intersects. Tức là, dữ liệu từ vùng đệm được nối với các điểm mà chúng giao với nhau.Bây giờ chúng ta có thể đếm kết quả: có nrow(linelist_sf_hf_2k[.na(linelist_sf_hf_2k$osm_id.y),]) trường hợp trong số 1000 trường hợp không giao nhau với bất kỳ vùng đệm nào (giá trị đó bị thiếu), và đó họ sống ở nơi cách nhiều hơn 30 phút đi bộ tới cơ sở y tế gần nhất.Chúng ta có thể trực quan hóa kết quả sao cho các trường hợp không giao nhau với bất kỳ vùng đệm nào sẽ xuất hiện với màu đỏ.","code":"\nsle_hf_2k <- sle_hf %>%\n  st_buffer(dist=0.02)       # decimal degrees translating to approximately 2.5km \ntmap_mode(\"plot\")\n# Create circular buffers\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2)+\ntm_shape(sle_hf) +                    # plot clinic facilities in large red dots\n  tm_dots(size=0.3, col='black')      \n# Intersect the cases with the buffers\nlinelist_sf_hf_2k <- linelist_sf_hf %>%\n  st_join(sle_hf_2k, join = st_intersects, left = TRUE) %>%\n  filter(osm_id.x==osm_id.y | is.na(osm_id.y)) %>%\n  select(case_id, osm_id.x, nearest_clinic, amenity.x, osm_id.y)\n# Cases which did not get intersected with any of the health facility buffers\nlinelist_sf_hf_2k %>% \n  filter(is.na(osm_id.y)) %>%\n  nrow()## [1] 1000\ntmap_mode(\"view\")\n\n# First display the cases in points\ntm_shape(linelist_sf_hf) +\n  tm_dots(size=0.08, col='nearest_clinic') +\n\n# plot clinic facilities in large black dots\ntm_shape(sle_hf) +                    \n  tm_dots(size=0.3, col='black')+   \n\n# Then overlay the health facility buffers in polylines\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2) +\n\n# Highlight cases that are not part of any health facility buffers\n# in red dots  \ntm_shape(linelist_sf_hf_2k %>%  filter(is.na(osm_id.y))) +\n  tm_dots(size=0.1, col='red') +\ntm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))+\n\n# add title  \ntm_layout(title = \"Cases by clinic catchment area\")"},{"path":"gis.html","id":"các-hàm-nối-theo-không-gian-khác","chapter":"1 GIS cơ bản","heading":"Các hàm nối theo không gian khác","text":"Các giá trị tùy chọn cho đối số join bao gồm (lấy từ tài liệu này)st_contains_properlyst_containsst_covered_byst_coversst_crossesst_disjointst_equals_exactst_equalsst_is_within_distancest_nearest_featurest_overlapsst_touchesst_within","code":""},{"path":"gis.html","id":"bản-đồ-choropleth","chapter":"1 GIS cơ bản","heading":"1.7 Bản đồ Choropleth","text":"Bản đồ Choropleth có thể hữu ích để trực quan hóa dữ liệu của bạn theo khu vực được xác định trước, thường là đơn vị hành chính hoặc khu vực y tế. Ví dụ, trong ứng phó với ổ dịch, điều này có thể giúp xác định mục tiêu phân bổ nguồn lực cho các khu vực cụ thể có tỷ lệ mắc bệnh cao.Bây giờ chúng ta đã gán tên đơn vị hành chính cho tất cả các trường hợp (xem phần về phép nối không gian, ở trên), chúng ta có thể bắt đầu lập bản đồ số lượng trường hợp theo khu vực (bản đồ choropleth).Vì chúng ta cũng có dữ liệu dân số theo cấp hành chính cấp 3 (ADM3), chúng ta có thể thêm thông tin này vào bảng case_adm3 đã được tạo trước đó.Chúng ta bắt đầu với dataframe case_adm3 được tạo trong bước trước đó, là bảng tóm tắt của từng đơn vị hành chính và số lượng các trường hợp của nó.Dữ liệu dân số sle_adm3_pop được nối sử dụng hàm left_join() từ dplyr trên cơ sở các giá trị chung trên cột admin3pcod trong bộ dữ liệu case_adm3, và cột adm_pcode trong bộ dữ liệu sle_adm3_pop. Xem chương [Nối dữ liệu]).select() được áp dụng trên dataframe mới, để chỉ giữ những cột cần thiệt - total nghĩa là tổng dân sốCác trường hợp trên 10,000 dân được tính toán bằng cách tạo cột mới với hàm mutate()Nối bảng này với đa giác shapfile ADM3 để vẽ bản đồVẽ bản đồ kết quảChúng ta cũng có thể lập bản đồ tỷ suất mới mắc","code":"\n# Add population data and calculate cases per 10K population\ncase_adm3 <- case_adm3 %>% \n     left_join(sle_adm3_pop,                             # add columns from pop dataset\n               by = c(\"admin3pcod\" = \"adm3_pcode\")) %>%  # join based on common values across these two columns\n     select(names(case_adm3), total) %>%                 # keep only important columns, including total population\n     mutate(case_10kpop = round(cases/total * 10000, 3)) # make new column with case rate per 10000, rounded to 3 decimals\n\ncase_adm3                                                # print to console for viewing## # A tibble: 10 x 5\n## # Groups:   admin3pcod [10]\n##    admin3pcod admin3name     cases  total case_10kpop\n##    <chr>      <chr>          <int>  <int>       <dbl>\n##  1 SL040102   Mountain Rural   295  33993       86.8 \n##  2 SL040208   West III         234 210252       11.1 \n##  3 SL040207   West II          175 145109       12.1 \n##  4 SL040204   East II           99  99821        9.92\n##  5 SL040203   East I            51  68284        7.47\n##  6 SL040201   Central I         50  69683        7.18\n##  7 SL040206   West I            50  60186        8.31\n##  8 SL040202   Central II        21  23874        8.80\n##  9 SL040205   East III          21 500134        0.42\n## 10 <NA>       <NA>               4     NA       NA\ncase_adm3_sf <- case_adm3 %>%                 # begin with cases & rate by admin unit\n  left_join(sle_adm3, by=\"admin3pcod\") %>%    # join to shapefile data by common column\n  select(objectid, admin3pcod,                # keep only certain columns of interest\n         admin3name = admin3name.x,           # clean name of one column\n         admin2name, admin1name,\n         cases, total, case_10kpop,\n         geometry) %>%                        # keep geometry so polygons can be plotted\n  drop_na(objectid) %>%                       # drop any empty rows\n\n  st_as_sf()                                  # convert to shapefile\n# tmap mode\ntmap_mode(\"plot\")               # view static map\n\n# plot polygons\ntm_shape(case_adm3_sf) + \n        tm_polygons(\"cases\") +  # color by number of cases column\n        tm_text(\"admin3name\")   # name display\n# Cases per 10K population\ntmap_mode(\"plot\")             # static viewing mode\n\n# plot\ntm_shape(case_adm3_sf) +                # plot polygons\n  tm_polygons(\"case_10kpop\",            # color by column containing case rate\n              breaks=c(0, 10, 50, 100), # define break points for colors\n              palette = \"Purples\"       # use a purple color palette\n              ) +\n  tm_text(\"admin3name\")                 # display text"},{"path":"gis.html","id":"vẽ-bản-đồ-với-ggplot2","chapter":"1 GIS cơ bản","heading":"1.8 Vẽ bản đồ với ggplot2","text":"Nếu bạn đã quen với việc sử dụng ggplot2, bạn có thể sử dụng package này để vẽ bản đồ tĩnh cho dữ liệu của bạn. Hàm geom_sf() sẽ vẽ các đối tượng khác nhau dựa trên các đối tượng địa lý (điểm, đường thẳng hoặc đa giác) có trong dữ liệu của bạn. Ví dụ: bạn có thể sử dụng hàm geom_sf() trong ggplot() bằng cách sử dụng dữ liệu sf với dạng hình học đa giác để tạo bản đồ choropleth.Để minh họa cách thức hoạt động của nó, Chúng ta có thể bắt đầu với shapefile đa giác ADM3 mà chúng ta đã sử dụng lúc trước. Xin nhớ lại rằng đây là các khu vực hành chính cấp 3 ở Sierra Leone:Chúng ta có thể sử dụng hàm left_join() từ dplyr để thêm dữ liệu mà chúng ta muốn vẽ tới đối tượng shapefile. Trong trường hợp này, chúng ta sẽ sử dụng bộ dữ liệu case_adm3 mà chúng ta đã tạo trước đó để tóm tắt số lượng trường hợp theo khu vực hành chính; tuy nhiên, chúng ta có thể sử dụng phương pháp tương tự này để vẽ bất kỳ dữ liệu nào được lưu trữ trong data frame.Để tạo biểu đồ cột về số lượng trường hợp theo khu vực, sử dụng ggplot2, sau đó chúng ta có thể gọi geom_col() như sau:Nếu chúng ta muốn sử dụng ggplot2 để tạo bản đồ choropleth về số lượng trường hợp, chúng ta có thể sử dụng cú pháp tương tự để gọi hàm geom_sf():Sau đó, chúng ta có thể tùy chỉnh hình thức bản đồ bằng cách sử dụng ngữ pháp nhất quán trên ggplot2, ví dụ:Đối với người dùng R cảm thấy thoải mái khi làm việc với ggplot2, geom_sf() cung cấp một cách làm đơn giản và trực tiếp, phù hợp với việc trực quan hóa bản đồ cơ bản. Để tìm hiểu thêm, hãy đọc hướng dẫn geom_sf() này hoặc sách về ggplot2.","code":"\nsle_adm3## Simple feature collection with 12 features and 19 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -13.29894 ymin: 8.094272 xmax: -12.91333 ymax: 8.499809\n## Geodetic CRS:  WGS 84\n## # A tibble: 12 x 20\n##    objectid admin3name     admin3pcod admin3ref_n    admin2name   admin2pcod admin1name admin1pcod admin0name admin0pcod date       valid_on   valid_to\n##  *    <dbl> <chr>          <chr>      <chr>          <chr>        <chr>      <chr>      <chr>      <chr>      <chr>      <date>     <date>     <date>  \n##  1      155 Koya Rural     SL040101   Koya Rural     Western Are~ SL0401     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA      \n##  2      156 Mountain Rural SL040102   Mountain Rural Western Are~ SL0401     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA      \n##  3      157 Waterloo Rural SL040103   Waterloo Rural Western Are~ SL0401     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA      \n##  4      158 York Rural     SL040104   York Rural     Western Are~ SL0401     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA      \n##  5      159 Central I      SL040201   Central I      Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA      \n##  6      160 East I         SL040203   East I         Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA      \n##  7      161 East II        SL040204   East II        Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA      \n##  8      162 Central II     SL040202   Central II     Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA      \n##  9      163 West III       SL040208   West III       Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA      \n## 10      164 West I         SL040206   West I         Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA      \n## 11      165 West II        SL040207   West II        Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA      \n## 12      167 East III       SL040205   East III       Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA      \n## # ... with 7 more variables: shape_leng <dbl>, shape_area <dbl>, rowcacode0 <chr>, rowcacode1 <chr>, rowcacode2 <chr>, rowcacode3 <chr>,\n## #   geometry <MULTIPOLYGON [°]>\nsle_adm3_dat <- sle_adm3 %>% \n  inner_join(case_adm3, by = \"admin3pcod\") # inner join = retain only if in both data objects\n\nselect(sle_adm3_dat, admin3name.x, cases) # print selected variables to console## Simple feature collection with 9 features and 2 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -13.29894 ymin: 8.384533 xmax: -13.12612 ymax: 8.499809\n## Geodetic CRS:  WGS 84\n## # A tibble: 9 x 3\n##   admin3name.x   cases                                                                                geometry\n##   <chr>          <int>                                                                      <MULTIPOLYGON [°]>\n## 1 Mountain Rural   295 (((-13.21496 8.474341, -13.21479 8.474289, -13.21465 8.474296, -13.21455 8.474298, -...\n## 2 Central I         50 (((-13.22646 8.489716, -13.22648 8.48955, -13.22644 8.489513, -13.22663 8.489229, -1...\n## 3 East I            51 (((-13.2129 8.494033, -13.21076 8.494026, -13.21013 8.494041, -13.2096 8.494025, -13...\n## 4 East II           99 (((-13.22653 8.491883, -13.22647 8.491853, -13.22642 8.49186, -13.22633 8.491814, -1...\n## 5 Central II        21 (((-13.23154 8.491768, -13.23141 8.491566, -13.23144 8.49146, -13.23131 8.491294, -1...\n## 6 West III         234 (((-13.28529 8.497354, -13.28456 8.496497, -13.28403 8.49621, -13.28338 8.496086, -1...\n## 7 West I            50 (((-13.24677 8.493453, -13.24669 8.493285, -13.2464 8.493132, -13.24627 8.493131, -1...\n## 8 West II          175 (((-13.25698 8.485518, -13.25685 8.485501, -13.25668 8.485505, -13.25657 8.485504, -...\n## 9 East III          21 (((-13.20465 8.485758, -13.20461 8.485698, -13.20449 8.485757, -13.20431 8.485577, -...\nggplot(data=sle_adm3_dat) +\n  geom_col(aes(x=fct_reorder(admin3name.x, cases, .desc=T),   # reorder x axis by descending 'cases'\n               y=cases)) +                                  # y axis is number of cases by region\n  theme_bw() +\n  labs(                                                     # set figure text\n    title=\"Number of cases, by administrative unit\",\n    x=\"Admin level 3\",\n    y=\"Number of cases\"\n  ) + \n  guides(x=guide_axis(angle=45))                            # angle x-axis labels 45 degrees to fit better\nggplot(data=sle_adm3_dat) + \n  geom_sf(aes(fill=cases))    # set fill to vary by case count variable\nggplot(data=sle_adm3_dat) +                           \n  geom_sf(aes(fill=cases)) +                        \n  scale_fill_continuous(high=\"#54278f\", low=\"#f2f0f7\") +    # change color gradient\n  theme_bw() +\n  labs(title = \"Number of cases, by administrative unit\",   # set figure text\n       subtitle = \"Admin level 3\"\n  )"},{"path":"gis.html","id":"bản-đồ-cơ-sở","chapter":"1 GIS cơ bản","heading":"1.9 Bản đồ cơ sở","text":"","code":""},{"path":"gis.html","id":"openstreetmap","chapter":"1 GIS cơ bản","heading":"OpenStreetMap","text":"Dưới đây, chúng tôi mô tả cách lấy được bản đồ cơ sở cho bản đồ ggplot2 bằng cách sử dụng các tính năng của OpenStreetMap. Các phương pháp thay thế bao gồm sử dụng ggmap, yêu cầu bạn đăng ký miễn phí với Google (chi tiết).OpenStreetMap là một dự án hợp tác nhằm tạo ra một bản đồ thế giới có thể chỉnh sửa miễn phí. Dữ liệu vị trí địa lý nền tảng ví dụ: vị trí của các thành phố, đường xá, đặc điểm tự nhiên, sân bay, trường học, bệnh viện, đường xá, v.v.) được coi là đầu ra chính của dự án.Đầu tiên, chúng ta gọi package OpenStreetMap để lấy bản đồ cơ sở.Sau đó chúng ta tạo đối tượng map, được xác định bằng cách sử dụng hàm openmap() từ package OpenStreetMap (tài liệu). Chúng ta cung cấp những thông tin sau:upperLeft và lowerRight Hai cặp tọa độ xác định giới hạn của ô bản đồ cơ sở\nTrong trường hợp này, chúng tôi đã đưa giá trị tối đa và tối thiểu từ các hàng trong linelist, vì vậy bản đồ sẽ tương tác động với dữ liệu\nupperLeft và lowerRight Hai cặp tọa độ xác định giới hạn của ô bản đồ cơ sởTrong trường hợp này, chúng tôi đã đưa giá trị tối đa và tối thiểu từ các hàng trong linelist, vì vậy bản đồ sẽ tương tác động với dữ liệuzoom = (nếu null nó sẽ được xác định tự động)zoom = (nếu null nó sẽ được xác định tự động)type = loại bản đồ cơ sở nào - chúng tôi đã liệt kê một số khả năng ở đây và code hiện đang sử dụng cái đầu tiên ([1]) “osm”type = loại bản đồ cơ sở nào - chúng tôi đã liệt kê một số khả năng ở đây và code hiện đang sử dụng cái đầu tiên ([1]) “osm”mergeTiles = chúng tôi đã chọn TRUE để tất cả các lớp nền được hợp nhất thành mộtmergeTiles = chúng tôi đã chọn TRUE để tất cả các lớp nền được hợp nhất thành mộtNếu chúng ta vẽ bản đồ cơ sở này ngay bây giờ, sử dụng hàm autoplot.OpenStreetMap() từ package OpenStreetMap, bạn sẽ thấy rằng các đơn vị trên các trục không phải là kinh/vĩ độ. Nó đang sử dụng một hệ tọa độ khác. Để hiển thị chính xác nơi cứ trú các trường hợp (được lưu trữ theo vĩ độ/kinh độ), điều này phải được thay đổi.Vì vậy, chúng ta muốn chuyển đổi bản đồ thành vĩ độ/kinh độ với hàm openproj() từ package OpenStreetMap. Chúng ta cung cấp bản đồ cơ sở map và cũng cung cấp Hệ thống tham chiếu tọa độ (CRS) mà chúng ta muốn. Chúng ta thực hiện điều này bằng cách cung cấp chuỗi ký tự “proj.4” cho phép chiếu WGS 1984, nhưng bạn cũng có thể cung cấp CRS theo những cách khác. (xem trang này để hiểu rõ hơn chuỗi proj.4 là gì)Bây giờ khi chúng ta tạo biểu đồ, chúng ta thấy rằng dọc theo các trục là tọa độ vĩ độ và kinh độ. Hệ tọa độ đã được chuyển đổi. Bây giờ các trường hợp của chúng ta sẽ được biểu diễn chính xác nếu được phủ lên!Xem các hướng dẫn tại đây và tại đây để biết thêm chi tiết.","code":"\n# load package\npacman::p_load(OpenStreetMap)\n\n# Fit basemap by range of lat/long coordinates. Choose tile type\nmap <- OpenStreetMap::openmap(\n  upperLeft = c(max(linelist$lat, na.rm=T), max(linelist$lon, na.rm=T)),   # limits of basemap tile\n  lowerRight = c(min(linelist$lat, na.rm=T), min(linelist$lon, na.rm=T)),\n  zoom = NULL,\n  type = c(\"osm\", \"stamen-toner\", \"stamen-terrain\", \"stamen-watercolor\", \"esri\",\"esri-topo\")[1])\nautoplot.OpenStreetMap(map)\n# Projection WGS84\nmap_latlon <- openproj(map, projection = \"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\")\n# Plot map. Must use \"autoplot\" in order to work with ggplot\nautoplot.OpenStreetMap(map_latlon)"},{"path":"gis.html","id":"bản-đồ-nhiệt-mật-độ-đường-viền","chapter":"1 GIS cơ bản","heading":"1.10 Bản đồ nhiệt mật độ đường viền","text":"Dưới đây, chúng tôi mô tả cách đạt được bản đồ nhiệt mật độ đường viền của các trường hợp, trên một bản đồ cơ sở, bắt đầu với một danh sách dòng (một dòng cho mỗi trường hợp).Tạo ô bản đồ cơ sở từ OpenStreetMap, như được mô tả ở trênVẽ biểu đồ các trường hợp từ linelist bằng cách sử dụng cột vĩ độ và kinh độChuyển đổi các điểm thành bản đồ nhiệt mật độ với hàm stat_density_2d() trong ggplot2,Khi chúng ta có một bản đồ cơ sở với tọa độ vĩ độ/kinh độ, chúng ta có thể vẽ các trường hợp của mình lên trên bằng cách sử dụng tọa độ vĩ độ/kinh độ của nơi cư trú của chúng.Xây dựng dựa trên hàm autoplot.OpenStreetMap() để tạo bản đồ cơ sở, các hàm ggplot2 sẽ dễ dàng thêm vào trên cùng, như được hiển thị với hàm geom_point() bên dưới:Bản đồ trên có thể khó giải thích, đặc biệt là với các điểm trùng lặp. Vì vậy, thay vào đó bạn có thể vẽ một bản đồ mật độ 2d bằng cách sử dụng hàm stat_density_2d() trong ggplot2. Bạn vẫn đang sử dụng tọa độ vĩ độ/kinh độ của linelist, nhưng ước tính mật độ lõi 2D được thực hiện và kết quả được hiển thị với các đường đồng mức - giống như bản đồ địa hình. Đọc bản đầy đủ tài liệu tại đây.","code":"\n# Plot map. Must be autoplotted to work with ggplot\nautoplot.OpenStreetMap(map_latlon)+                 # begin with the basemap\n  geom_point(                                       # add xy points from linelist lon and lat columns \n    data = linelist,                                \n    aes(x = lon, y = lat),\n    size = 1, \n    alpha = 0.5,\n    show.legend = FALSE) +                          # drop legend entirely\n  labs(x = \"Longitude\",                             # titles & labels\n       y = \"Latitude\",\n       title = \"Cumulative cases\")\n# begin with the basemap\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # add the density plot\n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # specify color scale\n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # labels \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases\")"},{"path":"gis.html","id":"bản-đồ-nhiệt-chuỗi-thời-gian","chapter":"1 GIS cơ bản","heading":"Bản đồ nhiệt chuỗi thời gian","text":"Bản đồ nhiệt mật độ ở trên cho thấy các trường hợp tích lũy. Chúng ta có thể khảo sát các vụ dịch theo thời gian và không gian bằng cách faceting bản đồ nhiệt dựa trên tháng khởi phát triệu chứng, như được rút ra từ linelist.Chúng ta bắt đầu với linelist, tạo một cột mới với Năm và Tháng khởi phát. Hàm format() trong base R thay đổi cách hiển thị ngày. Trong trường hợp này, chúng ta muốn “YYYY-MM”..Bây giờ, chúng ta chỉ cần đơn giản facet thông qua ggplot2 vào bản đồ nhiệt mật độ. facet_wrap() được áp dụng, sử dụng cột mới làm hàng. Chúng ta thiết lập số lượng cột được facet là 4 cho rõ ràng.","code":"\n# Extract month of onset\nlinelist <- linelist %>% \n  mutate(date_onset_ym = format(date_onset, \"%Y-%m\"))\n\n# Examine the values \ntable(linelist$date_onset_ym, useNA = \"always\")## \n## 2014-04 2014-05 2014-06 2014-07 2014-08 2014-09 2014-10 2014-11 2014-12 2015-01 2015-02 2015-03 2015-04    <NA> \n##       2      10       9      33      94     214     190     140      85      71      56      38      26      32\n# packages\npacman::p_load(OpenStreetMap, tidyverse)\n\n# begin with the basemap\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # add the density plot\n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # specify color scale\n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # labels \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases over time\")+\n  \n  # facet the plot by month-year of onset\n  facet_wrap(~ date_onset_ym, ncol = 4)               "},{"path":"gis.html","id":"thống-kê-không-gian","chapter":"1 GIS cơ bản","heading":"1.11 Thống kê không gian","text":"Hầu hết các cuộc thảo luận của chúng ta cho đến nay đều tập trung vào việc trực quan hóa dữ liệu không gian. Trong một số trường hợp, bạn cũng có thể quan tâm đến việc sử dụng thống kê không gian để định lượng mối quan hệ không gian của các thuộc tính trong dữ liệu của mình. Phần này sẽ cung cấp một cái nhìn tổng quan ngắn gọn về một số khái niệm chính trong thống kê không gian và đề xuất một số tài liệu sẽ hữu ích để khám phá nếu bạn muốn thực hiện các phân tích không gian toàn diện hơn.","code":""},{"path":"gis.html","id":"mối-quan-hệ-không-gian","chapter":"1 GIS cơ bản","heading":"Mối quan hệ không gian","text":"Trước khi có thể tính toán bất kỳ số liệu thống kê không gian nào, chúng ta cần xác định mối quan hệ giữa các đối tượng địa lý trong dữ liệu của mình. Có nhiều cách để khái niệm hóa các mối quan hệ không gian, nhưng một mô hình đơn giản và thường được áp dụng để sử dụng là mô hình adjancy - liền kề - cụ thể là chúng ta mong đợi mối quan hệ địa lý giữa các khu vực có chung biên giới hoặc “láng giềng” với nhau..Chúng ta có thể định lượng các mối quan hệ liền kề giữa các vùng địa giới hành chính trong dữ liệu sle_adm3 mà chúng ta đang sử dụng với package spdep. Chúng ta sẽ cụ thể sự tiếp giáp queen, có nghĩa là các khu vực sẽ là hàng xóm của nhau nếu chúng có chung ít nhất một điểm dọc theo biên giới của chúng. Phương pháp thay thế có thể là sự tiếp giáp rook, đòi hỏi các khu vực phải chia sẻ một cạnh - trong trường hợp của chúng ta, với các đa giác không đều, sự phân biệt là không đáng kể, nhưng trong một số trường hợp, sự lựa chọn giữa queen và rook có thể có ảnh hưởng.Ma trận được ở trên hiển thị mối quan hệ giữa 9 vùng trong dữ liệu sle_adm3 của chúng ta. Điểm 0 cho biết hai vùng không phải là láng giềng, trong khi bất kỳ giá trị nào khác 0 cho biết mối quan hệ láng giềng. Các giá trị trong ma trận được chia tỷ lệ để mỗi vùng có tổng trọng số hàng là 1.Một cách tốt hơn để trực quan hóa những mối quan hệ láng giềng này là vẽ biểu đồ chúng:Chúng ta đã sử dụng phương pháp tiếp cận adjacency để xác định các đa giác hàng xóm; những người hàng xóm mà chúng ta đã xác định đôi khi cũng được gọi là những người hàng xóm dựa trên sự tiếp giáp. Nhưng đây chỉ là một cách để lựa chọn các khu vực dự kiến có mối quan hệ địa lý. Các cách tiếp cận thay thế phổ biến nhất để xác định các mối quan hệ địa lý tạo ra những người hàng xóm dựa trên khoảng cách; ngắn gọn thì chúng là:K-nearest neighbors - Dựa trên khoảng cách giữa các tâm (trung tâm có trọng số địa lý của mỗi vùng đa giác), hãy chọn n vùng gần nhất làm vùng lân cận. Ngưỡng khoảng cách tối đa cũng có thể được chỉ định. Trong spdep, bạn có thể sử dụng hàm knearneigh() (xem tài liệu).K-nearest neighbors - Dựa trên khoảng cách giữa các tâm (trung tâm có trọng số địa lý của mỗi vùng đa giác), hãy chọn n vùng gần nhất làm vùng lân cận. Ngưỡng khoảng cách tối đa cũng có thể được chỉ định. Trong spdep, bạn có thể sử dụng hàm knearneigh() (xem tài liệu).Distance threshold neighbors - Chọn tất cả hàng xóm trong một ngưỡng khoảng cách. Trong spdep, các mối quan hệ láng giềng này có thể được xác định bằng cách sử dụng hàm dnearneigh() (xem tài liệu).Distance threshold neighbors - Chọn tất cả hàng xóm trong một ngưỡng khoảng cách. Trong spdep, các mối quan hệ láng giềng này có thể được xác định bằng cách sử dụng hàm dnearneigh() (xem tài liệu).","code":"\nsle_nb <- spdep::poly2nb(sle_adm3_dat, queen=T) # create neighbors \nsle_adjmat <- spdep::nb2mat(sle_nb)    # create matrix summarizing neighbor relationships\nsle_listw <- spdep::nb2listw(sle_nb)   # create listw (list of weights) object -- we will need this later\n\nsle_nb## Neighbour list object:\n## Number of regions: 9 \n## Number of nonzero links: 30 \n## Percentage nonzero weights: 37.03704 \n## Average number of links: 3.333333\nround(sle_adjmat, digits = 2)##   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n## 1 0.00 0.20 0.00 0.20 0.00  0.2 0.00 0.20 0.20\n## 2 0.25 0.00 0.00 0.25 0.25  0.0 0.00 0.25 0.00\n## 3 0.00 0.00 0.00 0.50 0.00  0.0 0.00 0.00 0.50\n## 4 0.25 0.25 0.25 0.00 0.00  0.0 0.00 0.00 0.25\n## 5 0.00 0.33 0.00 0.00 0.00  0.0 0.33 0.33 0.00\n## 6 0.50 0.00 0.00 0.00 0.00  0.0 0.00 0.50 0.00\n## 7 0.00 0.00 0.00 0.00 0.50  0.0 0.00 0.50 0.00\n## 8 0.20 0.20 0.00 0.00 0.20  0.2 0.20 0.00 0.00\n## 9 0.33 0.00 0.33 0.33 0.00  0.0 0.00 0.00 0.00\n## attr(,\"call\")\n## spdep::nb2mat(neighbours = sle_nb)\nplot(sle_adm3_dat$geometry) +                                           # plot region boundaries\n  spdep::plot.nb(sle_nb,as(sle_adm3_dat, 'Spatial'), col='grey', add=T) # add neighbor relationships"},{"path":"gis.html","id":"tự-tương-quan-không-gian","chapter":"1 GIS cơ bản","heading":"Tự tương quan không gian","text":"Định luật địa lý đầu tiên được trích dẫn của Tobler tuyên bố rằng “mọi thứ đều liên quan đến mọi thứ khác, nhưng những thứ ở gần có liên quan hơn những thứ ở xa”. Trong dịch tễ học, điều này thường có nghĩa là nguy cơ về một kết quả sức khỏe cụ thể ở một vùng nhất định tương tự với các vùng lân cận hơn là những vùng xa. Khái niệm này đã được chính thức hóa dưới dạng tự tương quan không gian - thuộc tính thống kê mà các đối tượng địa lý có giá trị tương tự được nhóm lại với nhau trong không gian. Các phép đo thống kê về tự tương quan không gian có thể được sử dụng để định lượng mức độ phân cụm không gian trong dữ liệu của bạn, xác định vị trí xảy ra phân cụm, và xác định các xu hướng chung về tự tương quan không gian giữa các biến khác nhau trong dữ liệu của bạn. Phần này giới thiệu tổng quan về một số thước đo phổ biến của tự tương quan không gian và cách tính chúng trong R.Moran’s - Đây là thống kê tóm tắt mang tính toàn cục (global) về mối tương quan giữa giá trị của một biến trong một vùng và giá trị của cùng một biến ở các vùng lân cận. Thống kê Moran’s thường dao động từ -1 tới 1. Giá trị 0 cho thấy không có tương quan không gian, trong khi các giá trị gần 1 hoặc -1 cho thấy tự tương quan không gian (các giá trị tương tự gần nhau) hoặc phân tán không gian (các giá trị không tương tự ở gần nhau) mạnh hơn.Ví dụ: chúng ta sẽ tính toán thống kê Moran’s để định lượng tự tương quan theo không gian trong các trường hợp Ebola mà chúng ta đã mapping trước đó (hãy nhớ rằng đây là một tập con các trường hợp từ một vụ dịch mô phỏng trong dataframe linelist). Package spdep có hàm moran.test có thể giúp chúng ta thực hiện phép tính toán này:Đầu ra từ hàm moran.test() cho chúng ta thấy kết quả thống kê Moran statistic từ hàm round(moran_i$estimate[1],2). Điều này cho thấy sự hiện diện của tự tương quan không gian trong dữ liệu của chúng ta - cụ thể là những khu vực có số ca mắc Ebola tương tự nhau thì có khả năng ở gần nhau. Giá trị p cung cấp bởi kiểm định moran.test() được tạo ra bằng cách sánh với kỳ vọng trong giả thuyết không là không có tự tương quan không gian, và có thể được sử dụng nếu bạn cần báo cáo kết quả của một kiểm định giả thuyết chính thức.Local Moran’s - Chúng ta có thể phân tách thống kê Moran’s (toàn cục - global) được tính toán ở trên để xác định tự tương quan cục bộ (local); nghĩa là, để xác định các cụm cụ thể trong dữ liệu của chúng ta. Thống kê này, đôi khi còn được gọi là Local Indicator Spatial Association (LISA), tóm tắt mức độ tự tương quan không gian xung quanh mỗi vùng riêng lẻ. Nó có thể hữu ích để tìm các điểm “nóng - hot” và “lạnh - cold” trên bản đồ.Để hiển thị một ví dụ, chúng ta có thể tính toán và lập bản đồ Local Moran’s cho các trường hợp Ebola ở trên với hàm local_moran() từ package spdep:Getis-Ord Gi* - Đây là một thống kê khác thường được sử dụng để phân tích điểm nóng - hotspot analysis; mức độ phổ biến của thống kê này liên quan đến ứng dụng của nó trong công cụ Phân tích điểm nóng của ArcGIS. Nó dựa trên giả định rằng thông thường, sự khác biệt về giá trị của một biến giữa các vùng lân cận phải tuân theo phân phối chuẩn. Nó sử dụng cách tiếp cận z-score để xác định các vùng có giá trị cao hơn đáng kể (điểm nóng) hoặc thấp hơn đáng kể (điểm lạnh) của một biến cụ thể, với các vùng lân cận của chúng..Chúng ta có thể tính toán và lập bản đồ chỉ số Gi* sử dụng hàm localG() từ package spdep:Như bạn có thể thấy, bản đồ được tạo ra bởi Getis-Ord Gi* trông hơi khác với bản đồ của Local Moran’s được tạo ra trước đó. Điều này phản ánh rằng phương pháp được sử dụng để tính toán hai số liệu thống kê này hơi khác nhau; bạn nên sử dụng cái nào tùy thuộc vào trường hợp sử dụng cụ thể của bạn và câu hỏi nghiên cứu quan tâm.Lee’s L test - Đây là một kiểm định thống kê về mối tương quan không gian giữa hai biến. Nó cho phép bạn kiểm định xem xu hướng không gian của một biến x có tương tự với xu hướng không gian của một biến y khác hay không, với giả định là chúng có mối tương quan không gian với nhauĐể đưa ra một ví dụ, hãy kiểm định liệu rằng xu hướng không gian các trường hợp Ebola từ một vụ dịch mô phỏng có tương quan với xu hướng không gian của dân số hay không. Để bắt đầu, chúng ta cần có một biến population trong bộ dữ liệu sle_adm3 của mình. Chúng ta có thể sử dụng biến total từ bộ dữ liệu sle_adm3_pop mà chúng ta đã tải trước đó.Chúng ta có thể trực quan hóa nhanh xu hướng không gian của hai biến cạnh nhau, để xem liệu chúng có tương tự nhau hay không:Một cách trực quan, các xu hướng có vẻ không giống nhau. Chúng ta có thể sử dụng hàm lee.test() trong package spdep để kiểm định liệu xu hướng tự tương quan không gian giữa hai biến số có liên quan có ý nghĩa thống kê với nhau hay không. Thống kê L sẽ gần tới 0 nếu không có mối tương quan giữa các xu hướng, gần bằng 1 nếu có mối tương quan dương mạnh (tức là các xu hướng tương tự nhau) và gần bằng -1 nếu có mối tương quan âm mạnh (tức là các xu hướng là ngược nhau).Kết quả từ thống kê Lee’s L cho hai biến là round(lee_test$estimate[1],2), chỉ ra rằng chúng có mối tương quan âm yếu. Điều này khẳng định đánh giá trực quan của chúng ta rằng xu hướng các trường hợp bệnh và dân số không liên quan đến nhau cũng như cung cấp bằng chứng rằng xu hướng không gian của các trường hợp không hoàn toàn là kết quả của mật độ dân số ở các khu vực có nguy cơ cao.Thống kê Lee L có thể hữu ích để đưa ra các suy luận về mối quan hệ phân bố theo không gian giữa các biến; tuy nhiên, để mô tả bản chất của mối quan hệ giữa hai biến một cách chi tiết hơn, hoặc điều chỉnh cho nhiễu, sẽ cần đến các kỹ thuật hồi quy không gian. Chúng sẽ được mô tả ngắn gọn trong phần sau.","code":"\nmoran_i <-spdep::moran.test(sle_adm3_dat$cases,    # numeric vector with variable of interest\n                            listw=sle_listw)       # listw object summarizing neighbor relationships\n\nmoran_i                                            # print results of Moran's I test## \n##  Moran I test under randomisation\n## \n## data:  sle_adm3_dat$cases  \n## weights: sle_listw    \n## \n## Moran I statistic standard deviate = 1.6646, p-value = 0.04799\n## alternative hypothesis: greater\n## sample estimates:\n## Moran I statistic       Expectation          Variance \n##        0.21726630       -0.12500000        0.04227615\n# calculate local Moran's I\nlocal_moran <- spdep::localmoran(                  \n  sle_adm3_dat$cases,                              # variable of interest\n  listw=sle_listw                                  # listw object with neighbor weights\n)\n\n# join results to sf data\nsle_adm3_dat<- cbind(sle_adm3_dat, local_moran)    \n\n# plot map\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=Ii)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Local Moran's I\") +\n  labs(title=\"Local Moran's I statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\n# Perform local G analysis\ngetis_ord <- spdep::localG(\n  sle_adm3_dat$cases,\n  sle_listw\n)\n\n# join results to sf data\nsle_adm3_dat$getis_ord <- getis_ord\n\n# plot map\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=getis_ord)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Gi*\") +\n  labs(title=\"Getis-Ord Gi* statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\nsle_adm3_dat <- sle_adm3_dat %>% \n  rename(population = total)                          # rename 'total' to 'population'\ntmap_mode(\"plot\")\n\ncases_map <- tm_shape(sle_adm3_dat) + tm_polygons(\"cases\") + tm_layout(main.title=\"Cases\")\npop_map <- tm_shape(sle_adm3_dat) + tm_polygons(\"population\") + tm_layout(main.title=\"Population\")\n\ntmap_arrange(cases_map, pop_map, ncol=2)   # arrange into 2x1 facets\nlee_test <- spdep::lee.test(\n  x=sle_adm3_dat$cases,          # variable 1 to compare\n  y=sle_adm3_dat$population,     # variable 2 to compare\n  listw=sle_listw                # listw object with neighbor weights\n)\n\nlee_test## \n##  Lee's L statistic randomisation\n## \n## data:  sle_adm3_dat$cases ,  sle_adm3_dat$population \n## weights: sle_listw  \n## \n## Lee's L statistic standard deviate = -1.0068, p-value = 0.843\n## alternative hypothesis: greater\n## sample estimates:\n## Lee's L statistic       Expectation          Variance \n##       -0.15197861       -0.04017851        0.01233165"},{"path":"gis.html","id":"hồi-quy-không-gian","chapter":"1 GIS cơ bản","heading":"Hồi quy không gian","text":"Bạn có thể muốn đưa ra các suy luận thống kê về mối quan hệ giữa các biến trong dữ liệu không gian của mình. Trong những trường hợp này, sẽ hữu ích khi xem xét các kỹ thuật hồi quy không gian - nghĩa là, các cách tiếp cận hồi quy xem xét rõ ràng tổ chức không gian của các đơn vị trong dữ liệu của bạn. Một số lý mà bạn có thể cần xem xét các mô hình hồi quy không gian, thay vì các mô hình hồi quy tiêu chuẩn như GLM, bao gồm:Các mô hình hồi quy tiêu chuẩn giả định rằng các phần dư là độc lập với nhau. Khi có hiện tượng tự tương quan không gian mạnh, các phần dư của mô hình hồi quy chuẩn cũng có khả năng tự tương quan không gian, đó vi phạm giả định này. Điều này có thể dẫn đến các vấn đề trong việc giải thích kết quả mô hình, trong trường hợp đó, một mô hình không gian sẽ được ưu tiên hơn.Các mô hình hồi quy tiêu chuẩn giả định rằng các phần dư là độc lập với nhau. Khi có hiện tượng tự tương quan không gian mạnh, các phần dư của mô hình hồi quy chuẩn cũng có khả năng tự tương quan không gian, đó vi phạm giả định này. Điều này có thể dẫn đến các vấn đề trong việc giải thích kết quả mô hình, trong trường hợp đó, một mô hình không gian sẽ được ưu tiên hơn.Các mô hình hồi quy cũng thường giả định rằng tác động của một biến x là không đổi đối với tất cả các quan sát. Trong trường hợp không đồng nhất về không gian - spatial heterogenity, các tác động mà chúng ta muốn ước tính có thể thay đổi theo không gian và chúng ta có thể quan tâm đến việc định lượng những khác biệt đó. Trong trường hợp này, các mô hình hồi quy không gian mang lại sự linh hoạt hơn cho việc ước lượng và giải thích các tác động.Các mô hình hồi quy cũng thường giả định rằng tác động của một biến x là không đổi đối với tất cả các quan sát. Trong trường hợp không đồng nhất về không gian - spatial heterogenity, các tác động mà chúng ta muốn ước tính có thể thay đổi theo không gian và chúng ta có thể quan tâm đến việc định lượng những khác biệt đó. Trong trường hợp này, các mô hình hồi quy không gian mang lại sự linh hoạt hơn cho việc ước lượng và giải thích các tác động.Các chi tiết về phương pháp tiếp cận hồi quy không gian nằm ngoài phạm vi của sổ tay này. Thay vào đó, phần này sẽ cung cấp tổng quan về các mô hình hồi quy không gian phổ biến nhất và cách sử dụng của chúng, đồng thời giới thiệu cho bạn tài liệu tham khảo có thể sử dụng nếu bạn muốn khám phá thêm lĩnh vực này.Các mô hình sai số không gian - Spatial error models - Các mô hình này giả định rằng sai số trên các đơn vị không gian có tương quan với nhau, trong trường hợp đó, dữ liệu sẽ vi phạm các giả định của mô hình OLS tiêu chuẩn. Các mô hình này đôi khi còn được biết đến với tên Các mô hình tự hồi quy đồng thời - simultaneous autoregressive (SAR) models. Mô hình được fit bằng cách sử dụng hàm errorsarlm() trong package spatialreg (các hàm hồi quy không gian là một phần của package spdep).Các mô hình độ trễ không gian - Spatial lag models - Các mô hình này giả định rằng biến phụ thuộc của một vùng không chỉ bị ảnh hưởng bởi giá trị của các biến độc lập trong , mà còn bởi giá trị của các biến đó ở các vùng lân cận . Tương tự như các mô hình sai số không gian, các mô hình độ trễ không gian cũng thường được biết đến với tên gọi Các mô hình tự hồi quy đồng thời. Mô hình được fit bằng cách sử dụng hàm lagsarlm() trong package spatialreg.Package spdep chứa một số kiểm định hữu ích để quyết định lựa chọn giữa các mô hình OLS chuẩn, độ trễ không gian và sai số không gian. Các kiểm định này được gọi là chẩn đoán Lagrange Multiplier, có thể được sử dụng để xác định loại phụ thuộc không gian trong dữ liệu của bạn và chọn mô hình nào phù hợp nhất. Hàm lm.LMtests() có thể được sử dụng để tính toán tất cả các kiểm định Lagrange Multiplier. Anselin (1988) cũng cung cấp một sơ đồ khối hữu ích để quyết định sử dụng mô hình hồi quy không gian nào dựa trên kết quả của các kiểm định Lagrange Multiplier:Các mô hình Bayesian phân tầng - Bayesian hierarchical models - Phương pháp tiếp cận Bayes thường được sử dụng cho một số ứng dụng trong phân tích không gian, phổ biến nhất là lập bản đồ dịch bệnh. Chúng được ưu tiên sử dụng trong các trường hợp dữ liệu trường hợp được phân phối thưa thớt (ví dụ trong trường hợp các outcome là hiếm gặp) hoặc “nhiễu” về mặt thống kê, vì chúng có thể được sử dụng để tạo ra các ước tính “mượt mà” về nguy cơ bệnh tật bằng cách tính đến quy trình không gian tiềm ẩn cơ bản. Điều này có thể giúp cải thiện chất lượng của các ước tính. Chúng cũng cho phép người điều tra cụ thể trước (thông qua việc lựa chọn prior) các xu hướng tương quan không gian phức tạp có thể tồn tại trong dữ liệu, mà có thể giải thích cho các sự biến động phụ thuộc hoặc không phụ thuộc không gian trong cả biến độc lập và phụ thuộc. Trong R, các mô hình Bayesian phân tầng có thể sử dụng thông qua package CARbayes (xem hưỡng dẫn) hoặc R-INLA (xem trang web và sách giáo khoa). R cũng có thể được sử dụng để gọi phần mềm bên ngoài thực hiện ước lượng Bayes, chẳng hạn như JAGS hoặc WinBUGS.","code":""},{"path":"gis.html","id":"tài-nguyên-học-liệu","chapter":"1 GIS cơ bản","heading":"1.12 Tài nguyên học liệu","text":"R Các tính năng cơ bản và package sf vignetteR Các tính năng cơ bản và package sf vignetteR tmap package vignetteR tmap package vignetteggmap: Trực quan hóa không gian với ggplot2ggmap: Trực quan hóa không gian với ggplot2Giới thiệu về cách tạo bản đồ với R, tổng quan về các package khác nhauGiới thiệu về cách tạo bản đồ với R, tổng quan về các package khác nhauDữ liệu không gian trong R (khóa học EarthLab)Dữ liệu không gian trong R (khóa học EarthLab)Phân tích dữ liệu không gian ứng dụng trong R sách giáo khoaPhân tích dữ liệu không gian ứng dụng trong R sách giáo khoaSpatialEpiApp - một ứng dụng Shiny có thể tải xuống dưới dạng một package trong R, cho phép bạn cung cấp dữ liệu của riêng mình và tiến hành lập bản đồ, phân tích cụm và thống kê không gian.SpatialEpiApp - một ứng dụng Shiny có thể tải xuống dưới dạng một package trong R, cho phép bạn cung cấp dữ liệu của riêng mình và tiến hành lập bản đồ, phân tích cụm và thống kê không gian.Giới thiệu về kinh tế lượng không gian với R hội thảoGiới thiệu về kinh tế lượng không gian với R hội thảo","code":""},{"path":"epicurves.html","id":"epicurves","chapter":"2 Đường cong dịch bệnh","heading":"2 Đường cong dịch bệnh","text":"Đường cong dịch bệnh (còn được gọi là “đường cong epi”) là một biểu đồ dịch tễ học cốt lõi thường được sử dụng để trực quan xu hướng khởi phát bệnh theo thời gian trong một cụm hoặc nhóm ca bệnh.Phân tích đường cong dịch bệnh có thể cho biết xu hướng theo thời gian, giá trị ngoại lai, mức độ bùng phát dịch, khoảng thời gian có khả năng bị phơi nhiễm cao nhất, khoảng thời gian giữa các thế hệ ca bệnh và thậm chí có thể giúp xác định phương thức lây truyền của một căn bệnh không xác định (ví dụ: điểm bắt nguồn, nguồn tiếp diễn phổ biến, lây truyền từ người sang người). Bạn có thể tìm thấy một bài học trực tuyến về giải thích các đường cong dịch bệnh tại trang web của CDC Hoa Kỳ.Trong chương này, chúng tôi trình bày hai cách tiếp cận để tạo ra đường cong dịch bệnh trong R:Package incidence2, có thể tạo ra đường cong dịch bệnh với các lệnh đơn giảnPackage ggplot2, cho phép khả năng tùy chỉnh nâng cao thông qua các lệnh phức tạp hơnChúng tôi cũng sẽ giải quyết các trường hợp cụ thể như:Lập biểu đồ dữ liệu đếm tổng hợpFaceting hoặc tạo nhiều cấu phần nhỏÁp dụng đường trung bình độngHiển thị dữ liệu “dự kiến” hoặc có thể bị chậm trễ trong báo cáoThêm tỷ lệ ca nhiễm mới tích lũy bằng cách sử dụng trục thứ hai","code":""},{"path":"epicurves.html","id":"chuẩn-bị-1","chapter":"2 Đường cong dịch bệnh","heading":"2.1 Chuẩn bị","text":"","code":""},{"path":"epicurves.html","id":"packages","chapter":"2 Đường cong dịch bệnh","heading":"Packages","text":"Đoạn code này hiển thị cách gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, sẽ cài đặt package nếu cần và gọi package để sử dụng. Bạn cũng có thể cài đặt package với hàm library() từ base R. Xem chương [R cơ bản] để biết thêm thông tin về các package trong R.","code":"\npacman::p_load(\n  rio,          # file import/export\n  here,         # relative filepaths \n  lubridate,    # working with dates/epiweeks\n  aweek,        # alternative package for working with dates/epiweeks\n  incidence2,   # epicurves of linelist data\n  i2extras,     # supplement to incidence2\n  stringr,      # search and manipulate character strings\n  forcats,      # working with factors\n  RColorBrewer, # Color palettes from colorbrewer2.org\n  tidyverse     # data management + ggplot2 graphics\n) "},{"path":"epicurves.html","id":"nhập-dữ-liệu","chapter":"2 Đường cong dịch bệnh","heading":"Nhập dữ liệu","text":"Hai bộ dữ liệu mẫu được sử dụng trong chương này:Bộ số liệu linelist về các ca bệnh từ một vụ dịch mô phỏngSố lượng tổng hợp theo bệnh viện từ cùng một dịch bệnh mô phỏng bên trênCác bộ dữ liệu được nhập bằng hàm import() từ package rio. Xem chương [Nhập xuất dữ liệu] để biết các cách nhập dữ liệu khác nhau.Bộ số liệu linelistChúng ta nhập bộ dữ liệu về các ca bệnh mô phỏng từ một vụ dịch Ebola. Nếu bạn muốn tải xuống dữ liệu để làm theo từng bước, hãy xem hướng dẫn trong chương [Tải sách và dữ liệu]. Chúng tôi giả sử các tệp tin nằm trong thư mục làm việc nên không có thư mục con nào được chỉ định trong đường dẫn này.50 dòng đầu tiên được hiển thị như bên dưới:Số lượng ca bệnh bệnh viện tổng hợpTheo mục tiêu của cuốn sách này, bộ dữ liệu về số lượng tổng hợp hàng tuần theo bệnh viện được tạo từ linelist với đoạn code sau.50 dòng đầu tiên được hiển thị như bên dưới:","code":"\nlinelist <- import(\"linelist_cleaned.xlsx\")\n# import the counts data into R\ncount_data <- linelist %>% \n  group_by(hospital, date_hospitalisation) %>% \n  summarize(n_cases = dplyr::n()) %>% \n  filter(date_hospitalisation > as.Date(\"2013-06-01\")) %>% \n  ungroup()"},{"path":"epicurves.html","id":"thiết-lập-các-tham-số","chapter":"2 Đường cong dịch bệnh","heading":"Thiết lập các tham số","text":"Để tạo báo cáo, bạn có thể muốn thiết lập các thông số có thể chỉnh sửa, chẳng hạn như ngày dữ liệu hiện tại (“ngày dữ liệu”). Sau đó, bạn có thể tham chiếu đối tượng data_date trong code khi áp dụng bộ lọc hoặc trong chú thích động.","code":"\n## set the report date for the report\n## note: can be set to Sys.Date() for the current date\ndata_date <- as.Date(\"2015-05-15\")"},{"path":"epicurves.html","id":"xác-minh-ngày","chapter":"2 Đường cong dịch bệnh","heading":"Xác minh ngày","text":"Xác minh rằng mỗi cột ngày có liên quan là phân lớp Ngày và có phạm vi giá trị thích hợp. Bạn có thể thực hiện việc này đơn giản bằng cách sử dụng hàm hist() cho histogram hoặc hàm range() với na.rm=TRUE, hoặc với hàm ggplot() như bên dưới.","code":"\n# check range of onset dates\nggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset))"},{"path":"epicurves.html","id":"đường-cong-dịch-bệnh-với-package-incidence2","chapter":"2 Đường cong dịch bệnh","heading":"2.2 Đường cong dịch bệnh với package incidence2","text":"Dưới đây, chúng tôi trình bày cách tạo các đường cong dịch bệnh bằng cách sử dụng package precision2. Các tác giả của package này đã cố gắng cho phép người dùng tạo và sửa đổi các đường cong dịch bệnh mà không cần biết cú pháp ggplot2. Phần lớn nội dung của chương này được điều chỉnh từ minh họa của package, bạn có thể tìm thấy tại trang github của package incidence2.","code":""},{"path":"epicurves.html","id":"ví-dụ-đơn-giản","chapter":"2 Đường cong dịch bệnh","heading":"Ví dụ đơn giản","text":"Cần có 2 bước để vẽ đường cong dịch bệnh với package incidence2:Tạo một incidence object (sử dụng hàm incidence())\nCung cấp dữ liệu\nXác định cột ngày tại date_index =\nXác định khoảng thời gian interval = các ca nên được tổng hợp (hàng ngày, tuần, tháng..)\nXác định bất kỳ cột dùng để nhóm nào (ví dụ như giới tính, bệnh viện, kết quả)\nTạo một incidence object (sử dụng hàm incidence())Cung cấp dữ liệuXác định cột ngày tại date_index =Xác định khoảng thời gian interval = các ca nên được tổng hợp (hàng ngày, tuần, tháng..)Xác định bất kỳ cột dùng để nhóm nào (ví dụ như giới tính, bệnh viện, kết quả)Vẽ biểu đồ incidence object\nXác định nhãn, màu, tiêu đề, …\nVẽ biểu đồ incidence objectXác định nhãn, màu, tiêu đề, …Dưới đây, chúng tôi gọi package incidence2, tạo incidence object từ dữ liệu linelist trên cột date_onset và tổng hợp các trường hợp theo ngày. Sau đó, chúng tôi ra tóm tắt về đối tượng incidence object.Đối tượng incidence2 trông giống như một tibble (một kiểu data frame) và có thể được hiển thị hoặc thao tác thêm như một bộ dữ liệu.Đây là thông tin khi được hiển thị. Nó có một cột date_index và một cột count .Bạn cũng có thể tổng hợp thông tin của đối tượng:Để vẽ biểu đồ incidence object, hãy sử dụng hàm plot() với tên của incidence object. Trong nền, hàm plot.incidence2() đã được gọi, vì vậy để đọc tài liệu cụ thể về incidence2, bạn cần chạy lệnh ?plot.incidence2.Nếu bạn nhận thấy nhiều đường dọc nhỏ màu trắng, hãy cố gắng điều chỉnh kích thước hình ảnh của bạn. Ví dụ: nếu bạn xuất biểu đồ bằng ggsave(), bạn có thể cung cấp giá trị số cho width = và height =. Nếu bạn mở rộng biểu đồ, những đường đó có thể biến mất.","code":"\n# load incidence2 package\npacman::p_load(incidence2)\n\n# create the incidence object, aggregating cases by day\nepi_day <- incidence(       # create incidence object\n  x = linelist,             # dataset\n  date_index = date_onset,  # date column\n  interval = \"day\"          # date grouping interval\n  )\nclass(epi_day)## [1] \"incidence2\"   \"incidence_df\" \"tbl_df\"       \"tbl\"          \"data.frame\"\nepi_day## An incidence object: 367 x 2\n## date range: [2014-04-07] to [2015-04-30]\n## cases: 5632\n## interval: 1 day\n## \n##    date_index count\n##    <date>     <int>\n##  1 2014-04-07     1\n##  2 2014-04-15     1\n##  3 2014-04-21     2\n##  4 2014-04-25     1\n##  5 2014-04-26     1\n##  6 2014-04-27     1\n##  7 2014-05-01     2\n##  8 2014-05-03     1\n##  9 2014-05-04     1\n## 10 2014-05-05     1\n## # ... with 357 more rows\n# print summary of the incidence object\nsummary(epi_day)## date range: [2014-04-07] to [2015-04-30]\n## cases: 5632\n## interval: 1 day\n## timespan: 389 days\n# plot the incidence object\nplot(epi_day)"},{"path":"epicurves.html","id":"thay-đổi-khoảng-thời-gian-tổng-hợp-ca-bệnh","chapter":"2 Đường cong dịch bệnh","heading":"Thay đổi khoảng thời gian tổng hợp ca bệnh","text":"Đối số interval = của hàm incidence() xác định cách các quan sát được nhóm thành các cột dọc trong biểu đồ.Xác định khoảng thời gianincidence2 đem lại sự linh hoạt và cú pháp dễ hiểu để bạn có thể dễ dàng tổng hợp số ca bệnh thành các biểu đồ cột-đường cong dịch bệnh. Cung cấp một giá trị như những giá trị bên dưới cho đối số interval =. Bạn có thể viết bất kỳ thông tin nào bên dưới dưới dạng số nhiều (ví dụ: “weeks”) và bạn có thể thêm số phía trước (ví dụ: “3 months”).Dưới đây là ví dụ về các khoảng thời gian khác nhau trông như thế nào khi áp dụng vào bộ số liệu linelist. Lưu ý cách mà định dạng mặc định và tần suất của các nhãn thời gian trên trục x thay đổi khi khoảng thời gian thay đổi.Ngày đầu tiênBạn có thể tùy chọn chỉ định một giá trị thuộc phân lớp Ngày (ví dụ: .Date(\"2016-05-01\")) tới đối số firstdate = trong lệnh incidence(). Nếu được cung cấp, dữ liệu sẽ được cắt bớt theo phạm vi này và khoảng thời gian sẽ bắt đầu từ ngày này.","code":"\n# Create the incidence objects (with different intervals)\n##############################\n# Weekly (Monday week by default)\nepi_wk      <- incidence(linelist, date_onset, interval = \"Monday week\")\n\n# Sunday week\nepi_Sun_wk  <- incidence(linelist, date_onset, interval = \"Sunday week\")\n\n# Three weeks (Monday weeks by default)\nepi_2wk     <- incidence(linelist, date_onset, interval = \"2 weeks\")\n\n# Monthly\nepi_month   <- incidence(linelist, date_onset, interval = \"month\")\n\n# Quarterly\nepi_quarter   <- incidence(linelist, date_onset, interval = \"quarter\")\n\n# Years\nepi_year   <- incidence(linelist, date_onset, interval = \"year\")\n\n\n# Plot the incidence objects (+ titles for clarity)\n############################\nplot(epi_wk)+      labs(title = \"Monday weeks\")\nplot(epi_Sun_wk)+  labs(title = \"Sunday weeks\")\nplot(epi_2wk)+     labs(title = \"2 (Monday) weeks\")\nplot(epi_month)+   labs(title = \"Months\")\nplot(epi_quarter)+ labs(title = \"Quarters\")\nplot(epi_year)+    labs(title = \"Years\")"},{"path":"epicurves.html","id":"nhóm","chapter":"2 Đường cong dịch bệnh","heading":"Nhóm","text":"Các nhóm được chỉ định trong lệnh incidence() và có thể được sử dụng để tô màu cho các cột hoặc facet dữ liệu. Để chỉ định các nhóm trong dữ liệu của bạn, hãy cung cấp tên cột tới đối số groups = trong hàm incidence() (không có dấu ngoặc kép xung quanh tên cột). Nếu chỉ định nhiều cột, hãy để tên các cột bên trong hàm c().Bạn có thể chỉ định rằng các trường hợp có giá trị bị thiếu trong các cột được nhóm được liệt kê như một nhóm NA riêng biệt bằng cách thiết lập na_as_group = TRUE. Nếu không, chúng sẽ bị loại khỏi biểu đồ.Để tô màu các cột theo cột nhóm, bạn cần cung cấp lại tên cột tới đối số fill = trong lệnh plot().Để tô màu các cột theo cột nhóm, bạn cần cung cấp lại tên cột tới đối số fill = trong lệnh plot().Để facet dựa trên cột nhóm, hãy xem phần bên dưới về facet với incidence2.Để facet dựa trên cột nhóm, hãy xem phần bên dưới về facet với incidence2.Trong ví dụ dưới đây, các trường hợp trong toàn bộ đợt bùng phát được nhóm theo phân loại tuổi của họ. Các giá trị thiếu được đưa vào một nhóm. Khoảng thời gian của đường cong bệnh dịch là tuần.MẸO: Thay đổi tiêu đề của chú giải bằng cách thêm + lệnh ggplot2 labs(fill = \"title\") vào biểu đồ incidence2.Bạn cũng có thể để các cột được nhóm hiển thị cạnh nhau bằng cách đặt stack = FALSE trong plot(), như được hiển thị bên dưới:Bạn có thể đặt đối số na_as_group = thành FALSE trong lệnh incidence() để loại bỏ các hàng có giá trị bị thiếu khỏi biểu đồ.","code":"\n# Create incidence object, with data grouped by age category\nage_outbreak <- incidence(\n  linelist,                # dataset\n  date_index = date_onset, # date column\n  interval = \"week\",       # Monday weekly aggregation of cases\n  groups = age_cat,        # age_cat is set as a group\n  na_as_group = TRUE)      # missing values assigned their own group\n\n# plot the grouped incidence object\nplot(\n  age_outbreak,             # incidence object with age_cat as group\n  fill = age_cat)+          # age_cat is used for bar fill color (must have been set as a groups column above)\nlabs(fill = \"Age Category\") # change legend title from default \"age_cat\" (this is a ggplot2 modification)\n# Make incidence object of monthly counts. \nmonthly_gender <- incidence(\n linelist,\n date_index = date_onset,\n interval = \"month\",\n groups = gender            # set gender as grouping column\n)\n\nplot(\n  monthly_gender,   # incidence object\n  fill = gender,    # display bars colored by gender\n  stack = FALSE)    # side-by-side (not stacked)"},{"path":"epicurves.html","id":"lọc-dữ-liệu","chapter":"2 Đường cong dịch bệnh","heading":"Lọc dữ liệu","text":"Để vẽ biểu đồ đường cong dịch bệnh của một bộ dữ liệu con:Lọc bộ số liệu linelistCung cấp dữ liệu đã lọc vào lệnh incidence()Vẽ biểu đồ incidence objectVí dụ dưới đây sử dụng dữ liệu được lọc để chỉ hiển thị các trường hợp tại Central Hospital.","code":"\n# filter the linelist\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")\n\n# create incidence object using filtered data\ncentral_outbreak <- incidence(central_data, date_index = date_onset, interval = \"week\")\n\n# plot the incidence object\nplot(central_outbreak, title = \"Weekly case incidence at Central Hospital\")"},{"path":"epicurves.html","id":"số-lượng-tổng-hợp","chapter":"2 Đường cong dịch bệnh","heading":"Số lượng tổng hợp","text":"Nếu dữ liệu ban đầu của bạn được tổng hợp (số lượng), hãy cung cấp tên của cột chứa thông tin về số lượng ca tới đối số count = khi tạo incidence object với hàm incidence().Ví dụ, data frame count_data này được tổng hợp từ linelist theo số lượng hàng ngày theo bệnh viện. 50 hàng đầu tiên hiển thị như sau:Nếu bạn đang bắt đầu phân tích với dữ liệu đếm hàng ngày như bộ dữ liệu ở trên, thì lệnh incidence() để chuyển đổi dữ liệu này thành đường cong dịch bệnh hàng tuần theo bệnh viện sẽ trông như sau:","code":"\nepi_counts <- incidence(              # create weekly incidence object\n  count_data,                         # dataset with counts aggregated by day\n  date_index = date_hospitalisation,  # column with dates\n  count = n_cases,                    # column with counts\n  interval = \"week\",                  # aggregate daily counts up to weeks\n  groups = hospital                   # group by hospital\n  )\n\n# plot the weekly incidence epi curve, with stacked bars by hospital\nplot(epi_counts,                      # incidence object\n     fill = hospital)                 # color the bars by hospital"},{"path":"epicurves.html","id":"facetscác-biểu-đồ-nhỏ","chapter":"2 Đường cong dịch bệnh","heading":"Facets/Các biểu đồ nhỏ","text":"Để facet dữ liệu theo nhóm (ví dụ tạo “các biểu đồ nhỏ”):Xác định các cột dùng để facet tới đối số groups = khi bạn tạo incidence objectSử dụng lệnh facet_plot() thay cho plot()Xác định cột nhóm nào được sử dụng cho fill = và cho facets =Dưới đây, chúng ta thiết lập cả hai cột hospital và outcome làm cột chia nhóm trong lệnh incidence(). Sau đó, trong lệnh facet_plot(), chúng ta vẽ biểu đồ đường cong dịch bệnh, chỉ rõ rằng chúng ta muốn có các đường cong dịch bệnh khác nhau cho mỗi bệnh viện và trong mỗi đường cong dịch bệnh, các cột được xếp chồng lên nhau và được tô màu theo outcome.Lưu ý rằng package ggtree (được sử dụng để trực quan cây phả hệ) cũng có một hàm là facet_plot() - đây là lý tại sao chúng ta phải cụ thể incidence2::facet_plot() như ở trên.","code":"\nepi_wks_hosp_out <- incidence(\n  linelist,                      # dataset\n  date_index = date_onset,       # date column\n  interval = \"month\",            # monthly bars  \n  groups = c(outcome, hospital)  # both outcome and hospital are given as grouping columns\n  )\n\n# plot\nincidence2::facet_plot(\n  epi_wks_hosp_out,      # incidence object\n  facets = hospital,     # facet column\n  fill = outcome)        # fill column"},{"path":"epicurves.html","id":"hiệu-chỉnh-với-plot","chapter":"2 Đường cong dịch bệnh","heading":"Hiệu chỉnh với plot()","text":"Một đường cong dịch bệnh được tạo ra bởi incidence2 có thể được sửa đổi thông qua các đối số trong hàm plot().Dưới đây là các đối số của hàm plot() dùng để điều chỉnh hình thức cột:Dưới đây là các đối số của hàm plot() để sửa đổi trục ngày tháng:Lưu ý rằng đối số date_breaks = chỉ hoạt động nếu centre_dates = FALSE. Cung cấp giá trị ký tự trong dấu ngoặc kép bằng cú pháp strptime như bên dưới, như đã được trình bày chi tiết trong chương [Làm việc với ngày tháng]. Bạn có thể sử dụng \\n để tạo “dòng mới”.%d = Số ngày của tháng (5, 17, 28, …)\n%j = Số ngày của năm (ngày Julian 001-366)\n%= Ngày trong tuần viết tắt (Mon, Tue, Wed, …)\n%= Ngày trong tuần viết đầy đủ (Monday, Tuesday, …)\n%w = Số thứ tự ngày của tuần (0-6, Chủ nhật là 0)\n%u = Số thứ tự ngày của tuần (1-7, Thứ hai là 1)\n%W = Số thứ tự tuần (00-53, Thứ hai là ngày bắt đầu tuần mới)\n%U = Số thứ tự tuần (01-53, Chủ nhật là ngày bắt đầu tuần mới)\n%m = Số thứ tự tháng (Ví dụ 01, 02, 03, 04)\n%b = Tháng viết tắt (Jan, Feb, …)\n%B = Tháng viết đầy đủ (January, February, …)\n%y = Năm viết dạng 2 ký tự (Ví dụ 89)\n%Y = Năm viết dạng 2 ký tự (Ví dụ 1989)\n%H = giờ (khung 24 giờ)\n%M = phút\n%S = giây\n%z = bù từ múi giờ GMT\n%Z = Múi giờ (ký tự)Dưới đây là các đối số trong hàm plot() để hiệu chỉnh các nhãn trong biểu đồ:Một ví dụ sử dụng kết hợp các đối số ở trên:Để điều chỉnh thêm giao diện hiển thị của biểu đồ, hãy xem mục bên dưới về các hiệu chỉnh với hàm ggplot().","code":"\n# filter the linelist\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")\n\n# create incidence object using filtered data\ncentral_outbreak <- incidence(\n  central_data,\n  date_index = date_onset,\n  interval = \"week\",\n  groups = outcome)\n\n# plot incidence object\nplot(\n  central_outbreak,\n  fill = outcome,                       # box/bar color\n  legend = \"top\",                       # legend on top\n  title = \"Cases at Central Hospital\",  # title\n  xlab = \"Week of onset\",               # x-axis label\n  ylab = \"Week of onset\",               # y-axis label\n  show_cases = TRUE,                    # show each case as an individual box\n  alpha = 0.7,                          # transparency \n  border = \"grey\",                      # box border\n  angle = 30,                           # angle of date labels\n  centre_dates = FALSE,                 # date labels at edge of bar\n  date_format = \"%a %d %b %Y\\n(Week %W)\" # adjust how dates are displayed\n  )"},{"path":"epicurves.html","id":"hiệu-chỉnh-với-ggplot2","chapter":"2 Đường cong dịch bệnh","heading":"Hiệu chỉnh với ggplot2","text":"Bạn có thể hiệu chỉnh biểu đồ được tạo bởi incidence2 bằng cách thêm các hiệu chỉnh ggplot2 với dấu + sau khi đóng ngoặc hàm biểu diễn tỷ lệ mắc bệnh plot(), như được minh họa bên dưới.Dưới đây, biểu đồ incidence2 kết thúc và ngay sau đó các lệnh ggplot2 được sử dụng để sửa đổi các trục, thêm chú thích và điều chỉnh phông chữ đậm và kích thước chữ.Lưu ý rằng nếu bạn thêm scale_x_date(), hầu hết các định dạng ngày từ plot() sẽ bị ghi đè. Xem mục đường cong dịch bệnh với ggplot() và chương [Các tips với ggplot] để có thêm lựa chọn.","code":"\n# filter the linelist\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")\n\n# create incidence object using filtered data\ncentral_outbreak <- incidence(\n  central_data,\n  date_index = date_onset,\n  interval = \"week\",\n  groups = c(outcome))\n\n# plot incidence object\nplot(\n  central_outbreak,\n  fill = outcome,                       # box/bar color\n  legend = \"top\",                       # legend on top\n  title = \"Cases at Central Hospital\",  # title\n  xlab = \"Week of onset\",               # x-axis label\n  ylab = \"Week of onset\",               # y-axis label\n  show_cases = TRUE,                    # show each case as an individual box\n  alpha = 0.7,                          # transparency \n  border = \"grey\",                      # box border\n  centre_dates = FALSE,                   \n  date_format = \"%a %d %b\\n%Y (Week %W)\", \n  angle = 30                           # angle of date labels\n  )+\n  \n  scale_y_continuous(\n    breaks = seq(from = 0, to = 30, by = 5),  # specify y-axis increments by 5\n    expand = c(0,0))+                         # remove excess space below 0 on y-axis\n  \n  # add dynamic caption\n  labs(\n    fill = \"Patient outcome\",                               # Legend title\n    caption = stringr::str_glue(                            # dynamic caption - see page on characters and strings for details\n      \"n = {central_cases} from Central Hospital\n      Case onsets range from {earliest_date} to {latest_date}. {missing_onset} cases are missing date of onset and not shown\",\n      central_cases = nrow(central_data),\n      earliest_date = format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y'),\n      latest_date = format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y'),      \n      missing_onset = nrow(central_data %>% filter(is.na(date_onset)))))+\n  \n  # adjust bold face, and caption position\n  theme(\n    axis.title = element_text(size = 12, face = \"bold\"),    # axis titles larger and bold\n    axis.text = element_text(size = 10, face = \"bold\"),     # axis text size and bold\n    plot.caption = element_text(hjust = 0, face = \"italic\") # move caption to left\n  )"},{"path":"epicurves.html","id":"đổi-màu","chapter":"2 Đường cong dịch bệnh","heading":"Đổi màu","text":"","code":""},{"path":"epicurves.html","id":"chỉ-định-bảng-màu","chapter":"2 Đường cong dịch bệnh","heading":"Chỉ định bảng màu","text":"Cung cấp tên của bảng màu đã được định danh trước tới tham số col_pal = trong hàm plot(). Package incidence2 đi kèm với 2 bảng màu được xác định trước: “vibrant” và “muted”. Trong “vibrant”, có 6 màu đầu tiên là riêng biệt và trong “muted” có 9 màu đầu tiên là khác biệt. Sau những con số này, các màu là sự thêm vào/trung gian của các màu khác. Bạn có thể tìm thấy những bảng màu được xác định trước này tại website này. Các bảng màu loại trừ màu xám, nó được dành riêng cho dữ liệu bị thiếu (sử dụng na_color = để thay đổi mặc định này).Bạn cũng có thể sử dụng một trong các bảng màu trong base R (đặt tên của bảng màu không có dấu ngoặc kép).Bạn cũng có thể thêm bảng màu từ package viridis hoặc package RColorBrewer. Đầu tiên các package đó cần được tải, sau đó thêm các hàm scale_fill_*() tương ứng của chúng bằng dấu +, như bên dưới đây.","code":"\n# Create incidence object, with data grouped by age category  \nage_outbreak <- incidence(\n  linelist,\n  date_index = date_onset,   # date of onset for x-axis\n  interval = \"week\",         # weekly aggregation of cases\n  groups = age_cat)\n\n# plot the epicurve with default palette\nplot(age_outbreak, fill = age_cat, title = \"'vibrant' default incidence2 palette\")\n\n# plot with different color palette\n#plot(age_outbreak, fill = age_cat, col_pal = muted, title = \"'muted' incidence2 palette\")\n# plot with base R palette\nplot(age_outbreak, fill = age_cat, col_pal = heat.colors, title = \"base R heat.colors palette\")\n\n# plot with base R palette\nplot(age_outbreak, fill = age_cat, col_pal = rainbow, title = \"base R rainbow palette\")\npacman::p_load(RColorBrewer, viridis)\n\n# plot with color palette\nplot(age_outbreak, fill = age_cat, title = \"Viridis palette\")+\n  scale_fill_viridis_d(\n    option = \"inferno\",     # color scheme, try also \"plasma\" or the default\n    name = \"Age Category\",  # legend name\n    na.value = \"grey\")      # for missing values\n\n# plot with color palette\nplot(age_outbreak, fill = age_cat, title = \"RColorBrewer palette\")+\n  scale_fill_brewer(\n    palette = \"Dark2\",      # color palette, try also Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3\n    name = \"Age Category\",  # legend name\n    na.value = \"grey\")      # for missing values"},{"path":"epicurves.html","id":"xác-định-thủ-công","chapter":"2 Đường cong dịch bệnh","heading":"Xác định thủ công","text":"Để chỉ định màu theo cách thủ công, hãy thêm hàm scale_fill_manual() trong ggplot2 sau hàm plot() bằng dấu + và cung cấp vectơ tên màu hoặc mã HEX tới đối số values =. Số lượng màu được liệt kê phải bằng số nhóm. Hãy lưu ý, các giá trị bị thiếu có phải là một nhóm hay không - chúng có thể được chuyển đổi thành giá trị dạng ký tự chẳng hạn như “Missing” trong quá trình chuẩn bị dữ liệu của bạn bằng hàm fct_explicit_na(), như đã được giải thích trong chương [Factors].Như đã đề cập trong chương [Các tips với ggplot], bạn có thể tạo bảng màu của riêng mình bằng cách sử dụng hàm colorRampPalette() trên một vectơ chứa tên các màu sắc và chỉ định số màu bạn muốn trả về. Đây là một cách tốt để có thể thu được nhiều màu trong một lần bằng cách chỉ định một vài màu.","code":"\n# manual colors\nplot(age_outbreak, fill = age_cat, title = \"Manually-specified colors\")+\n  scale_fill_manual(\n    values = c(\"darkgreen\", \"darkblue\", \"purple\", \"grey\", \"yellow\", \"orange\", \"red\", \"lightblue\"),  # colors\n    name = \"Age Category\")      # Name for legend\nmy_cols <- c(\"darkgreen\", \"darkblue\", \"purple\", \"grey\", \"yellow\", \"orange\")\nmy_palette <- colorRampPalette(my_cols)(12)  # expand the 6 colors above to 12 colors\nmy_palette##  [1] \"#006400\" \"#00363F\" \"#00097E\" \"#3A0BAF\" \"#821ADD\" \"#A84BE2\" \"#B592CB\" \"#C9C99B\" \"#E7E745\" \"#FFF600\" \"#FFCD00\" \"#FFA500\""},{"path":"epicurves.html","id":"điều-chỉnh-thứ-bậc","chapter":"2 Đường cong dịch bệnh","heading":"Điều chỉnh thứ bậc","text":"Để điều chỉnh thứ tự xuất hiện của nhóm (trên biểu đồ và trong chú giải), cột phân nhóm cần phải là kiểu Factor. Xem chương [Factors] để biết thêm thông tin.Đầu tiên, chúng ta hãy quan sát một đường cong dịch bệnh hàng tuần theo bệnh viện với thứ tự mặc định:Bây giờ, để điều chỉnh thứ tự sao cho nhóm phân loại “Missing” và “” ở trên cùng của đường cong dịch bệnh, chúng ta có thể làm như sau:Gọi package forcats, để làm việc với cột định dạng factorGọi package forcats, để làm việc với cột định dạng factorĐiều chỉnh bộ dữ liệu - trong trường hợp này, chúng tôi sẽ xác định một bộ dữ liệu mới (plot_data) trong đó:\nCột gender được xác định là một biến phân loại có thứ bậc được thiết lập bằng hàm fct_relevel() sao cho “” và “Missing” đứng đầu tiên, đó chúng xuất hiện ở trên đầu các cột\nĐiều chỉnh bộ dữ liệu - trong trường hợp này, chúng tôi sẽ xác định một bộ dữ liệu mới (plot_data) trong đó:Cột gender được xác định là một biến phân loại có thứ bậc được thiết lập bằng hàm fct_relevel() sao cho “” và “Missing” đứng đầu tiên, đó chúng xuất hiện ở trên đầu các cộtIncidence object được tạo và vẽ biểu đồ như trước đóIncidence object được tạo và vẽ biểu đồ như trước đóChúng ta thêm các điều chỉnh ggplot2\nscale_fill_manual() để gán màu theo cách thủ công sao cho “Missing” là màu xám và “” là màu \nChúng ta thêm các điều chỉnh ggplot2scale_fill_manual() để gán màu theo cách thủ công sao cho “Missing” là màu xám và “” là màu beMẸO: Nếu bạn chỉ muốn đảo ngược thứ tự của chú giải, hãy thêm lệnh ggplot2 này guides(fill = guide_legend(reverse = TRUE)).","code":"\n# ORIGINAL - hospital NOT as factor\n###################################\n\n# create weekly incidence object, rows grouped by hospital and week\nhospital_outbreak <- incidence(\n  linelist,\n  date_index = date_onset, \n  interval = \"week\", \n  groups = hospital)\n\n# plot incidence object\nplot(hospital_outbreak, fill = hospital, title = \"ORIGINAL - hospital not a factor\")\n# MODIFIED - hospital as factor\n###############################\n\n# load forcats package for working with factors\npacman::p_load(forcats)\n\n# Convert hospital column to factor and adjust levels\nplot_data <- linelist %>% \n  mutate(hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))) # Set \"Missing\" and \"Other\" as top levels\n\n\n# Create weekly incidence object, grouped by hospital and week\nhospital_outbreak_mod <- incidence(\n  plot_data,\n  date_index = date_onset, \n  interval = \"week\", \n  groups = hospital)\n\n# plot incidence object\nplot(hospital_outbreak_mod, fill = hospital)+\n  \n  # manual specify colors\n  scale_fill_manual(values = c(\"grey\", \"beige\", \"darkgreen\", \"green2\", \"orange\", \"red\", \"pink\"))+                      \n\n  # labels added via ggplot\n  labs(\n      title = \"MODIFIED - hospital as factor\",   # plot title\n      subtitle = \"Other & Missing at top of epicurve\",\n      y = \"Weekly case incidence\",               # y axis title  \n      x = \"Week of symptom onset\",               # x axis title\n      fill = \"Hospital\")                         # title of legend     "},{"path":"epicurves.html","id":"đường-lưới-dọc","chapter":"2 Đường cong dịch bệnh","heading":"Đường lưới dọc","text":"Nếu bạn vẽ biểu đồ với các thiết lập mặc định của incidence2, bạn có thể nhận thấy rằng các đường lưới dọc xuất hiện ở từng nhãn ngày và giữa mỗi nhãn ngày. Điều này có thể dẫn đến các đường lưới giao nhau với đỉnh của một số cột.Bạn có thể xóa tất cả các đường lưới bằng cách thêm lệnh ggplot2 theme_classic().Tuy nhiên, lưu ý rằng nếu sử dụng tuần, các đối số date_breaks và date_minor_breaks chỉ hoạt động cho các tuần được quy định bắt đầu vào Thứ Hai. Nếu các tuần của bạn bắt đầu vào một ngày khác trong tuần, thay vào đó, bạn sẽ cần cung cấp vectơ ngày cho các đối số breaks = và minor_breaks = theo cách thủ công. Xem mục ggplot2 để biết các ví dụ về điều này bằng cách sử dụng hàm seq.Date().","code":"\n# make incidence object\na <- incidence(\n  central_data,\n  date_index = date_onset,\n  interval = \"Monday weeks\"\n)\n\n# Default gridlines\nplot(a, title = \"Default lines\")\n\n# Specified gridline intervals\n# NOT WORKING WITH INCIDENCE2 1.0.0\n# plot(a, title = \"Weekly lines\")+\n#   scale_x_date(\n#     date_breaks = \"4 weeks\",      # major vertical lines align on weeks\n#     date_minor_breaks = \"weeks\",  # minor vertical lines every week\n#     date_labels = \"%a\\n%d\\n%b\")   # format of date labels\n\n# No gridlines\nplot(a, title = \"No lines\")+\n  theme_classic()                 # remove all gridlines"},{"path":"epicurves.html","id":"số-mới-mắc-tích-lũy","chapter":"2 Đường cong dịch bệnh","heading":"Số mới mắc tích lũy","text":"Xem phần sau để biết phương pháp thay thế để vẽ biểu đồ số mới mắc tích lũy với ggplot2 - ví dụ: để chồng một đường số mới mắc tích lũy lên trên đường cong dịch bệnh.","code":""},{"path":"epicurves.html","id":"trung-bình-động","chapter":"2 Đường cong dịch bệnh","heading":"Trung bình động","text":"Bạn có thể thêm đường trung bình động vào biểu đồ tạo bởi incidence2 một cách dễ dàng với hàm add_rolling_average() từ package i2extras. Chuyển đối tượng incidence2 của bạn tới hàm này, và sau đó vẽ bằng hàm plot(). Thiết lập = là số ngày trước đó bạn muốn đưa vào đường trung bình động (mặc định là 2). Nếu dữ liệu của bạn được nhóm lại, trung bình động sẽ được tính cho mỗi nhóm.Để tìm hiểu cách áp dụng đường trung bình động một cách tổng quát hơn trên dữ liệu, hãy xem chương Đường trung bình động.","code":"\nrolling_avg <- incidence(                    # make incidence object\n  linelist,\n  date_index = date_onset,\n  interval = \"week\",\n  groups = gender) %>% \n  \n  i2extras::add_rolling_average(before = 6)  # add rolling averages (in this case, by gender)\n\n# plot\nplot(rolling_avg, n.breaks = 3) # faceted automatically because rolling average on groups"},{"path":"epicurves.html","id":"đường-cong-dịch-bệnh-với-ggplot2","chapter":"2 Đường cong dịch bệnh","heading":"2.3 Đường cong dịch bệnh với ggplot2","text":"Sử dụng ggplot() để xây dựng đường cong dịch bệnh cho phép sự linh hoạt và tùy chỉnh nhiều hơn, nhưng đòi hỏi nhiều nỗ lực và hiểu biết hơn về sử dụng ggplot().Không giống như sử dụng package incidence2, bạn phải kiểm soát thủ công việc tổng hợp các trường hợp theo thời gian (theo tuần, tháng, v.v.) và khoảng thời gian của các nhãn trên trục ngày thág. Việc này phải được quản lý rất cẩn thận.Các ví dụ này sử dụng một tập con của bộ dữ liệu linelist - chỉ các trường hợp từ Central Hospital.Để tạo ra một đường cong dịch bệnh với ggplot(), có ba yếu tố chính:Một histogram, với các ca bệnh linelist được tổng hợp thành các “bins” được phân biệt bằng các điểm “ngắt” cụ thểCân chỉnh các trục và nhãnChủ đề của biểu đồ, bao gồm tiêu đề, nhãn, chú thích, v.v.","code":"\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")"},{"path":"epicurves.html","id":"xác-định-bins-của-số-liệu","chapter":"2 Đường cong dịch bệnh","heading":"Xác định bins của số liệu","text":"Ở đây chúng ta trình bày cách xác định các ca bệnh sẽ được tổng hợp thành các bins của một histogram (“cột”). Điều quan trọng cần nhận ra là việc tổng hợp số ca bệnh thành các bins của một histogram không nhất thiết phải có cùng khoảng với thời gian xuất hiện trên trục x.Dưới đây có lẽ là đoạn code đơn giản nhất để tạo ra các đường cong dịch bệnh hàng ngày và hàng tuần.Trong lệnh ggplot() tổng quát, bộ dữ liệu được đưa vào data =. Trên nền tảng này, dạng hình học của histogram được thêm bằng một dấu +. Trong geom_histogram(), chúng ta ánh xạ các yếu tố thẩm mỹ sao cho cột date_onset được ánh xạ tới trục x. Cũng trong hàm geom_histogram() nhưng không phải trong đối số aes(), chúng ta đặt binwidth = bằng số bins của histogram, tính bằng ngày. Nếu cú pháp ggplot2 này khó hiểu, hãy xem lại chương [ggplot cơ bản].THẬN TRỌNG: Lập biểu đồ các trường hợp hàng tuần bằng cách sử dụng binwidth = 7 bắt đầu cột 7 ngày đầu tiên ở ca bệnh đầu tiên, mà có thể là bất kỳ ngày nào trong tuần! Để tạo các tuần cụ thể, hãy xem phần bên dưới.Chúng tôi xin lưu ý rằng ca bệnh đầu tiên trong bộ dữ liệu của Central Hospital có triệu chứng khởi phát vào ngày:Để chỉ định thủ công chia biểu đồ cột, không sử dụng argument binwidth = và thay vào đó cung cấp vectơ ngày để breaks =.Tạo vectơ ngày tháng với hàm seq.Date() trong base R. Hàm này sử dụng các đối số =, =, và =. Ví dụ: lệnh bên dưới trả về ngày mỗi tháng bắt đầu từ ngày 15 Tháng 1 và kết thúc trước ngày 28 Tháng 6.Vectơ này có được cung cấp cho hàm geom_histogram() dưới dạng breaks =:Một chuỗi ngày hàng tuần đơn giản có thể được trả về bằng cách đặt = \"week\". Ví dụ:Một giải pháp thay thế cho việc xác định ngày bắt đầu và ngày kết thúc cụ thể là viết code động để các cột hàng tuần bắt đầu vào thứ Hai trước ca đầu tiên. Chúng tôi sẽ sử dụng các vectơ ngày này trong suốt các ví dụ dưới đây.Hãy giải mã đoạn code khá “khoai” ở trên:Giá trị “” (ngày sớm nhất của chuỗi) được tạo như sau: giá trị ngày nhỏ nhất (min() với na.rm=TRUE) trong cột date_onset được đưa vào hàm floor_date() thuộc package lubridate. floor_date() được đặt thành “tuần” trả về ngày bắt đầu của “tuần” của trường hợp đó, với điều kiện là ngày bắt đầu của mỗi tuần là Thứ Hai (week_start = 1).Tương tự như vậy, giá trị “” (ngày kết thúc của chuỗi) được tạo bằng cách sử dụng hàm ngược lại ceiling_date() để trả về thứ hai sau ca cuối cùng.Đối số “” của seq.Date() có thể được đặt thành bất kỳ số ngày, tuần hoặc tháng nào.Sử dụng week_start = 7 cho tuần bắt đầu vào Chủ nhậtVì chúng ta sẽ sử dụng các vectơ ngày dạng này trong toàn bộ chương này, chúng ta cũng xác định một vectơ cho toàn bộ đợt bùng phát (ở trên chỉ dành cho Central Hospital).Các kết quả trả về của seq.Date() có thể được sử dụng để tạo các khoảng chia bins trong histogram, cũng như khoảng chia cho các nhãn ngày mà có thể độc lập với các bins. Đọc thêm về nhãn ngày trong các phần sau.MẸO: Đối với lệnh ggplot() đơn giản hơn, hãy lưu các khoảng chia bins và khoảng chia nhãn ngày dưới dạng các vectơ đã đặt tên trước và gán tên này vào đối số breaks =.","code":"\n# daily \nggplot(data = central_data) +          # set data\n  geom_histogram(                      # add histogram\n    mapping = aes(x = date_onset),     # map date column to x-axis\n    binwidth = 1)+                     # cases binned by 1 day \n  labs(title = \"Central Hospital - Daily\")                # title\n\n# weekly\nggplot(data = central_data) +          # set data \n  geom_histogram(                      # add histogram\n      mapping = aes(x = date_onset),   # map date column to x-axis\n      binwidth = 7)+                   # cases binned every 7 days, starting from first case (!) \n  labs(title = \"Central Hospital - 7-day bins, starting at first case\") # title\nformat(min(central_data$date_onset, na.rm=T), \"%A %d %b, %Y\")## [1] \"Thursday 01 May, 2014\"\nmonthly_breaks <- seq.Date(from = as.Date(\"2014-02-01\"),\n                           to = as.Date(\"2015-07-15\"),\n                           by = \"months\")\n\nmonthly_breaks   # print##  [1] \"2014-02-01\" \"2014-03-01\" \"2014-04-01\" \"2014-05-01\" \"2014-06-01\" \"2014-07-01\" \"2014-08-01\" \"2014-09-01\" \"2014-10-01\" \"2014-11-01\" \"2014-12-01\"\n## [12] \"2015-01-01\" \"2015-02-01\" \"2015-03-01\" \"2015-04-01\" \"2015-05-01\" \"2015-06-01\" \"2015-07-01\"\n# monthly \nggplot(data = central_data) +  \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    breaks = monthly_breaks)+         # provide the pre-defined vector of breaks                    \n  labs(title = \"Monthly case bins\")   # title\nweekly_breaks <- seq.Date(from = as.Date(\"2014-02-01\"),\n                          to = as.Date(\"2015-07-15\"),\n                          by = \"week\")\n# Sequence of weekly Monday dates for CENTRAL HOSPITAL\nweekly_breaks_central <- seq.Date(\n  from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # monday before first case\n  to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # monday after last case\n  by   = \"week\")\n# Sequence for the entire outbreak\nweekly_breaks_all <- seq.Date(\n  from = floor_date(min(linelist$date_onset, na.rm=T),   \"week\", week_start = 1), # monday before first case\n  to   = ceiling_date(max(linelist$date_onset, na.rm=T), \"week\", week_start = 1), # monday after last case\n  by   = \"week\")"},{"path":"epicurves.html","id":"ví-dụ-về-đường-cong-dịch-bệnh-theo-tuần","chapter":"2 Đường cong dịch bệnh","heading":"Ví dụ về đường cong dịch bệnh theo tuần","text":"Dưới đây là code ví dụ chi tiết để tạo đường cong dịch bệnh hàng tuần cho các tuần bắt đầu vào Thứ Hai, với các cột, nhãn ngày và đường lưới dọc đã được căn chỉnh. Phần này dành cho người dùng có nhu cầu code nhanh. Để hiểu sâu từng khía cạnh (chủ đề, nhãn ngày, v.v.), hãy tiếp tục xem các phần tiếp theo. Chú ý:Các đoạn chia bins của histogram được xác định bằng hàm seq.Date() như được giải thích ở trên để bắt đầu vào thứ Hai trước ca sớm nhất và kết thúc vào thứ Hai sau ca cuối cùngKhoảng nhãn ngày được xác định bởi date_breaks = bên trong scale_x_date()Khoảng đường lưới dọc nhỏ giữa các nhãn ngày được xác định bởi date_minor_breaks =expand = c(0,0) trong trục x và y loại bỏ không gian thừa trên mỗi cạnh của trục, điều này cũng đảm bảo các nhãn ngày bắt đầu từ cột đầu tiên.","code":"\n# TOTAL MONDAY WEEK ALIGNMENT\n#############################\n# Define sequence of weekly breaks\nweekly_breaks_central <- seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # Monday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # Monday after last case\n      by   = \"week\")    # bins are 7-days \n\n\nggplot(data = central_data) + \n  \n  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case\n  geom_histogram(\n    \n    # mapping aesthetics\n    mapping = aes(x = date_onset),  # date column mapped to x-axis\n    \n    # histogram bin breaks\n    breaks = weekly_breaks_central, # histogram bin breaks defined previously\n    \n    # bars\n    color = \"darkblue\",     # color of lines around bars\n    fill = \"lightblue\"      # color of fill within bars\n  )+ \n    \n  # x-axis labels\n  scale_x_date(\n    expand            = c(0,0),           # remove excess x-axis space before and after case bars\n    date_breaks       = \"4 weeks\",        # date labels and major vertical gridlines appear every 3 Monday weeks\n    date_minor_breaks = \"week\",           # minor vertical lines appear every Monday week\n    date_labels       = \"%a\\n%d %b\\n%Y\")+ # date labels format\n  \n  # y-axis\n  scale_y_continuous(\n    expand = c(0,0))+             # remove excess y-axis space below 0 (align histogram flush with x-axis)\n  \n  # aesthetic themes\n  theme_minimal()+                # simplify plot background\n  \n  theme(\n    plot.caption = element_text(hjust = 0,        # caption on left side\n                                face = \"italic\"), # caption in italics\n    axis.title = element_text(face = \"bold\"))+    # axis titles in bold\n  \n  # labels including dynamic caption\n  labs(\n    title    = \"Weekly incidence of cases (Monday weeks)\",\n    subtitle = \"Note alignment of bars, vertical gridlines, and axis labels on Monday weeks\",\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))"},{"path":"epicurves.html","id":"tuần-bắt-đầu-bằng-chủ-nhật","chapter":"2 Đường cong dịch bệnh","heading":"Tuần bắt đầu bằng Chủ nhật","text":"Để vẽ được biểu đồ cho các tuần bắt đầu bằng Chủ nhật, cần có một số sửa đổi, vì date_breaks = \"weeks\" chỉ hoạt động cho các tuần bắt đầu bằng thứ Hai.Các điểm ngắt của các histogram bins phải được đặt thành Chủ nhật (week_start = 7)Trong scale_x_date(), các đoạn ngắt ngày tương tự nên được gắn với breaks = và minor_breaks = để đảm bảo các nhãn ngày và đường lưới dọc căn chỉnh vào ngày Chủ nhật.Ví dụ: lệnh scale_x_date() cho các tuần bắt đầu vào Chủ nhật có thể trông như sau:","code":"scale_x_date(\n    expand = c(0,0),\n    \n    # specify interval of date labels and major vertical gridlines\n    breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Sunday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Sunday after last case\n      by   = \"4 weeks\"),\n    \n    # specify interval of minor vertical gridline \n    minor_breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Sunday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Sunday after last case\n      by   = \"week\"),\n   \n    # date label format\n    date_labels = \"%a\\n%d %b\\n%Y\")+         # day, above month abbrev., above 2-digit year"},{"path":"epicurves.html","id":"nhómtô-màu-theo-giá-trị","chapter":"2 Đường cong dịch bệnh","heading":"Nhóm/tô màu theo giá trị","text":"Các cột histogram có thể được tô màu theo nhóm và “xếp chồng lên nhau”. Để chỉ định cột nhóm, hãy thực hiện các thay đổi sau. Xem chương [ggplot cơ bản] để biết thêm chi tiết.Bên trong đối số aes() của hàm vẽ histogram, ánh xạ tên cột tới đối số group = và fill =Loại bỏ bất kỳ tham số fill = nào bên ngoài đối số aes(), vì nó sẽ ghi đè giá trị bên trongĐối số bên trong aes() sẽ áp dụng theo nhóm, trong khi bất kỳ đối số bên ngoài nào đều sẽ áp dụng cho tất cả các cột (ví dụ: bạn có thể vẫn muốn tô màu color = bên ngoài, vì vậy mỗi cột có cùng một đường viền)Đây là lệnh aes() hiển thị nhóm và tô màu các cột theo giới tính:Đây là kết quả khi áp dụng:","code":"\naes(x = date_onset, group = gender, fill = gender)\nggplot(data = linelist) +     # begin with linelist (many hospitals)\n  \n  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = hospital,       # set data to be grouped by hospital\n      fill = hospital),       # bar fill (inside color) by hospital\n    \n    # bin breaks are Monday weeks\n    breaks = weekly_breaks_all,   # sequence of weekly Monday bin breaks for whole outbreak, defined in previous code       \n    \n    # Color around bars\n    color = \"black\")"},{"path":"epicurves.html","id":"hiệu-chỉnh-màu","chapter":"2 Đường cong dịch bệnh","heading":"Hiệu chỉnh màu","text":"Để thiết lập thủ công tô màu cho từng nhóm, hãy sử dụng scale_fill_manual() (lưu ý: scale_color_manual() là một cái khác!)\nSử dụng đối số values = để áp dụng một vectơ màu\nSử dụng na.value = để xác định màu cho giá trị NA\nSử dụng đối số labels = để thay đổi văn bản trong mục chú thích. Để cho toàn, sử dụng một vectơ được đặt tên kiểu như c(\"old\" = \"new\", \"old\" = \"new\") hoặc điều chỉnh giá trị trong bộ dữ liệu\nSử dụng name = để đặt một tiêu đề thích hợp cho mục chú thích\nĐể thiết lập thủ công tô màu cho từng nhóm, hãy sử dụng scale_fill_manual() (lưu ý: scale_color_manual() là một cái khác!)Sử dụng đối số values = để áp dụng một vectơ màuSử dụng na.value = để xác định màu cho giá trị NASử dụng đối số labels = để thay đổi văn bản trong mục chú thích. Để cho toàn, sử dụng một vectơ được đặt tên kiểu như c(\"old\" = \"new\", \"old\" = \"new\") hoặc điều chỉnh giá trị trong bộ dữ liệuSử dụng name = để đặt một tiêu đề thích hợp cho mục chú thíchĐể biết thêm mẹo về thang màu và bảng màu, hãy xem chương [ggplot cơ bản].Để biết thêm mẹo về thang màu và bảng màu, hãy xem chương [ggplot cơ bản].","code":"\nggplot(data = linelist)+           # begin with linelist (many hospitals)\n  \n  # make histogram\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,          # cases grouped by hospital\n        fill = hospital),          # bar fill by hospital\n    \n    # bin breaks\n    breaks = weekly_breaks_all,        # sequence of weekly Monday bin breaks, defined in previous code\n    \n    # Color around bars\n    color = \"black\")+              # border color of each bar\n  \n  # manual specification of colors\n  scale_fill_manual(\n    values = c(\"black\", \"orange\", \"grey\", \"beige\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\") # specify fill colors (\"values\") - attention to order!"},{"path":"epicurves.html","id":"hiệu-chỉnh-thứ-bậc","chapter":"2 Đường cong dịch bệnh","heading":"Hiệu chỉnh thứ bậc","text":"Thứ tự mà các cột được nhóm xếp chồng lên nhau được điều chỉnh tốt nhất bằng cách phân loại cột nhóm dưới dạng Factor. Sau đó, bạn có thể chỉ định thứ tự cấp độ phân loại (và nhãn hiển thị của chúng). Xem chương về [Factors] hoặc [Các tips với ggplot] để biết thêm chi tiết.Trước khi tạo biểu đồ, hãy sử dụng hàm fct_relevel() từ package forcats để chuyển đổi cột phân nhóm thành kiểu Factor và điều chỉnh thứ tự cấp độ theo cách thủ công, như được trình bày chi tiết trong chương về [Factors].Trong biểu đồ dưới đây, điểm khác biệt duy nhất với trước đó là cột hospital đã được hợp nhất như trên và chúng ta sử dụng các guides() để đảo ngược thứ tự chú thích, đó “nhãn Missing” nằm ở cuối chú thích.MẸO: Để chỉ đảo ngược thứ tự của chú thích, hãy thêm lệnh ggplot2 này: guides(fill = guide_legend(reverse = TRUE)).","code":"\n# load forcats package for working with factors\npacman::p_load(forcats)\n\n# Define new dataset with hospital as factor\nplot_data <- linelist %>% \n  mutate(hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))) # Convert to factor and set \"Missing\" and \"Other\" as top levels to appear on epicurve top\n\nlevels(plot_data$hospital) # print levels in order## [1] \"Missing\"                              \"Other\"                                \"Central Hospital\"                    \n## [4] \"Military Hospital\"                    \"Port Hospital\"                        \"St. Mark's Maternity Hospital (SMMH)\"\nggplot(plot_data) +                     # Use NEW dataset with hospital as re-ordered factor\n  \n  # make histogram\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,               # cases grouped by hospital\n        fill = hospital),               # bar fill (color) by hospital\n    \n    breaks = weekly_breaks_all,         # sequence of weekly Monday bin breaks for whole outbreak, defined at top of ggplot section\n    \n    color = \"black\")+                   # border color around each bar\n    \n  # x-axis labels\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space before and after case bars\n    date_breaks       = \"3 weeks\",      # labels appear every 3 Monday weeks\n    date_minor_breaks = \"week\",         # vertical lines appear every Monday week\n    date_labels       = \"%d\\n%b\\n'%y\")+ # date labels format\n  \n  # y-axis\n  scale_y_continuous(\n    expand = c(0,0))+                   # remove excess y-axis space below 0\n  \n  # manual specification of colors, ! attention to order\n  scale_fill_manual(\n    values = c(\"grey\", \"beige\", \"black\", \"orange\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\")+ \n  \n  # aesthetic themes\n  theme_minimal()+                      # simplify plot background\n  \n  theme(\n    plot.caption = element_text(face = \"italic\", # caption on left side in italics\n                                hjust = 0), \n    axis.title = element_text(face = \"bold\"))+   # axis titles in bold\n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases by hospital\",\n    subtitle = \"Hospital as re-ordered factor\",\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly cases\")"},{"path":"epicurves.html","id":"hiệu-chỉnh-chú-thích","chapter":"2 Đường cong dịch bệnh","heading":"Hiệu chỉnh chú thích","text":"Đọc thêm về chú thích và scale trong chương [Các tips với ggplot]. Dưới đây là một vài điểm nổi bật:Chỉnh sửa tiêu đề chú thích trong hàm scale hoặc với labs(fill = \"Legend title\") (nếu bạn đang sử dụng color =, thì hãy sử dụng labs(color = \"\"))Chỉnh sửa tiêu đề chú thích trong hàm scale hoặc với labs(fill = \"Legend title\") (nếu bạn đang sử dụng color =, thì hãy sử dụng labs(color = \"\"))theme(legend.title = element_blank()) để bỏ trống tiêu đề chú thíchtheme(legend.title = element_blank()) để bỏ trống tiêu đề chú thíchtheme(legend.position = \"top\") (“bottom”, “left”, “right”, hoặc “none” để bỏ chú thích)theme(legend.position = \"top\") (“bottom”, “left”, “right”, hoặc “none” để bỏ chú thích)theme(legend.direction = \"horizontal\") xoay ngang chú thíchtheme(legend.direction = \"horizontal\") xoay ngang chú thíchguides(fill = guide_legend(reverse = TRUE)) để đảo ngược thứ tự các mục chú thíchguides(fill = guide_legend(reverse = TRUE)) để đảo ngược thứ tự các mục chú thích","code":""},{"path":"epicurves.html","id":"cột-kề-cột","chapter":"2 Đường cong dịch bệnh","heading":"Cột kề cột","text":"Hiển thị song song các cột nhóm (trái ngược với xếp chồng lên nhau) được chỉ định trong geom_histogram() với position = \"dodge\" được đặt bên ngoài aes().Nếu có nhiều hơn hai nhóm giá trị, nó có thể gây khó đọc. Thay vào đó, hãy cân nhắc sử dụng một biểu đồ được chia nhỏ (gồm nhiều biểu đồ nhỏ). Để dễ xem trong ví dụ này, các giá trị giới tính bị thiếu sẽ bị xóa.","code":"\nggplot(central_data %>% drop_na(gender))+   # begin with Central Hospital cases dropping missing gender\n    geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = gender,         # cases grouped by gender\n          fill = gender),         # bars filled by gender\n        \n        # histogram bin breaks\n        breaks = weekly_breaks_central,   # sequence of weekly dates for Central outbreak - defined at top of ggplot section\n        \n        color = \"black\",          # bar edge color\n        \n        position = \"dodge\")+      # SIDE-BY-SIDE bars\n                      \n  \n  # The labels on the x-axis\n  scale_x_date(expand            = c(0,0),         # remove excess x-axis space below and after case bars\n               date_breaks       = \"3 weeks\",      # labels appear every 3 Monday weeks\n               date_minor_breaks = \"week\",         # vertical lines appear every Monday week\n               date_labels       = \"%d\\n%b\\n'%y\")+ # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+             # removes excess y-axis space between bottom of bars and the labels\n  \n  #scale of colors and legend labels\n  scale_fill_manual(values = c(\"brown\", \"orange\"),  # specify fill colors (\"values\") - attention to order!\n                    na.value = \"grey\" )+     \n\n  # aesthetic themes\n  theme_minimal()+                                               # a set of themes to simplify plot\n  theme(plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n        axis.title = element_text(face = \"bold\"))+               # axis titles in bold\n  \n  # labels\n  labs(title    = \"Weekly incidence of cases, by gender\",\n       subtitle = \"Subtitle\",\n       fill     = \"Gender\",                                      # provide new title for legend\n       x        = \"Week of symptom onset\",\n       y        = \"Weekly incident cases reported\")"},{"path":"epicurves.html","id":"giới-hạn-trục","chapter":"2 Đường cong dịch bệnh","heading":"Giới hạn trục","text":"Có hai cách để giới hạn phạm vi các giá trị trên trục.Nói chung, cách khuyến khích sử dụng là lệnh coord_cartesian(), chấp nhận xlim = c(min, max) và ylim = c(min, max) (trong đó bạn cung cấp giá trị nhỏ nhất và lớn nhất). Cách này hoạt động như một “thu phóng kích thước” mà không thực sự loại bỏ bất kỳ dữ liệu nào, điều này rất quan trọng đối với các số liệu thống kê và các thang đo tổng hợp.Ngoài ra, bạn có thể thiết lập giá trị ngày tối đa và tối thiểu bằng cách sử dụng limits = c() bên trong hàm scale_x_date(). Ví dụ:Tương tự như vậy, nếu bạn muốn trục x kéo dài đến một ngày cụ thể (ví dụ: ngày hiện tại), ngay cả khi không có trường hợp mới nào được báo cáo, bạn có thể sử dụng:LƯU Ý: Hãy thận trọng khi đặt giới hạn hoặc chia tỷ lệ trục y (ví dụ: 0 đến 30 với khoảng là 5: seq(0, 30, 5)). Những con số tĩnh như vậy có thể cắt bớt biểu đồ quá ngắn nếu dữ liệu thay đổi vượt quá giới hạn!.","code":"\nscale_x_date(limits = c(as.Date(\"2014-04-01\"), NA)) # sets a minimum date but leaves the maximum open.  scale_x_date(limits = c(NA, Sys.Date()) # ensures date axis will extend until current date  "},{"path":"epicurves.html","id":"nhãnđường-lưới-của-trục-ngày","chapter":"2 Đường cong dịch bệnh","heading":"Nhãn/đường lưới của trục ngày","text":"MẸO: Hãy nhớ rằng các nhãn trục ngày độc lập với việc tổng hợp dữ liệu thành các cột, nhưng về mặt trực quan, điều quan trọng là phải căn chỉnh các cột, nhãn ngày và các đường lưới dọc.Để sửa đổi nhãn ngày và đường lưới, hãy sử dụng scale_x_date() theo một trong những cách sau:Nếu histogram bins là ngày, tuần bắt đầu vào thứ hai, tháng hoặc năm:\nSử dụng date_breaks = để xác định khoảng thời gian của các nhãn và đường lưới chính (ví dụ: “day”, “week”, “3 weeks”, “month” hoặc “year”)\nSử dụng date_minor_breaks = để xác định khoảng của các đường lưới dọc nhỏ (giữa các nhãn ngày)\nThêm expand = c(0,0) để bắt đầu các nhãn ở cột đầu tiên\nSử dụng date_labels = để xác định định dạng của nhãn ngày - hãy xem chương Ngày để biết các mẹo (sử dụng \\n cho một dòng mới)\nNếu histogram bins là ngày, tuần bắt đầu vào thứ hai, tháng hoặc năm:Sử dụng date_breaks = để xác định khoảng thời gian của các nhãn và đường lưới chính (ví dụ: “day”, “week”, “3 weeks”, “month” hoặc “year”)Sử dụng date_minor_breaks = để xác định khoảng của các đường lưới dọc nhỏ (giữa các nhãn ngày)Thêm expand = c(0,0) để bắt đầu các nhãn ở cột đầu tiênSử dụng date_labels = để xác định định dạng của nhãn ngày - hãy xem chương Ngày để biết các mẹo (sử dụng \\n cho một dòng mới)Nếu histogram bins là các tuần bắt đầu vào Chủ nhật:\nSử dụng breaks = và minor_breaks = bằng cách cung cấp một chuỗi ngày cho mỗi khoảng chia\nVẫn có thể sử dụng date_labels = và expand = để định dạng như mô tả ở trên\nNếu histogram bins là các tuần bắt đầu vào Chủ nhật:Sử dụng breaks = và minor_breaks = bằng cách cung cấp một chuỗi ngày cho mỗi khoảng chiaVẫn có thể sử dụng date_labels = và expand = để định dạng như mô tả ở trênMột số ghi chú:Xem phần mở đầu của mục ggplot về hướng dẫn cách tạo chuỗi ngày bằng seq.Date().Xem trang này hoặc chương [Làm việc với ngày tháng] để biết thêm mẹo tạo nhãn ngày.","code":""},{"path":"epicurves.html","id":"minh-họa","chapter":"2 Đường cong dịch bệnh","heading":"Minh họa","text":"Dưới đây là minh họa biểu đồ trong đó các cột và nhãn biểu đồ/đường lưới được căn chỉnh thẳng hàng và không thẳng hàng:","code":"\n# 7-day bins + Monday labels\n#############################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,                 # 7-day bins with start at first case\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),               # remove excess x-axis space below and after case bars\n    date_breaks = \"3 weeks\",       # Monday every 3 weeks\n    date_minor_breaks = \"week\",    # Monday weeks\n    date_labels = \"%a\\n%d\\n%b\\n'%y\")+  # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+              # remove excess space under x-axis, make flush\n  \n  labs(\n    title = \"MISALIGNED\",\n    subtitle = \"! CAUTION: 7-day bars start Thursdays at first case\\nDate labels and gridlines on Mondays\\nNote how ticks don't align with bars\")\n\n\n\n# 7-day bins + Months\n#####################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),                  # remove excess x-axis space below and after case bars\n    date_breaks = \"months\",           # 1st of month\n    date_minor_breaks = \"week\",       # Monday weeks\n    date_labels = \"%a\\n%d %b\\n%Y\")+    # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(\n    title = \"MISALIGNED\",\n    subtitle = \"! CAUTION: 7-day bars start Thursdays with first case\\nMajor gridlines and date labels at 1st of each month\\nMinor gridlines weekly on Mondays\\nNote uneven spacing of some gridlines and ticks unaligned with bars\")\n\n\n# TOTAL MONDAY ALIGNMENT: specify manual bin breaks to be mondays\n#################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Monday before first case\n    breaks = weekly_breaks_central,    # defined earlier in this page\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"4 weeks\",           # Monday every 4 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    date_labels = \"%a\\n%d %b\\n%Y\")+      # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(\n    title = \"ALIGNED Mondays\",\n    subtitle = \"7-day bins manually set to begin Monday before first case (28 Apr)\\nDate labels and gridlines on Mondays as well\")\n\n\n# TOTAL MONDAY ALIGNMENT WITH MONTHS LABELS:\n############################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Monday before first case\n    breaks = weekly_breaks_central,            # defined earlier in this page\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"months\",            # Monday every 4 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    date_labels = \"%b\\n%Y\")+          # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  theme(panel.grid.major = element_blank())+  # Remove major gridlines (fall on 1st of month)\n          \n  labs(\n    title = \"ALIGNED Mondays with MONTHLY labels\",\n    subtitle = \"7-day bins manually set to begin Monday before first case (28 Apr)\\nDate labels on 1st of Month\\nMonthly major gridlines removed\")\n\n\n# TOTAL SUNDAY ALIGNMENT: specify manual bin breaks AND labels to be Sundays\n############################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Sunday before first case\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"7 days\"),\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),\n    # date label breaks and major gridlines set to every 3 weeks beginning Sunday before first case\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"3 weeks\"),\n    \n    # minor gridlines set to weekly beginning Sunday before first case\n    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                            by   = \"7 days\"),\n    \n    date_labels = \"%a\\n%d\\n%b\\n'%y\")+  # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(title = \"ALIGNED Sundays\",\n       subtitle = \"7-day bins manually set to begin Sunday before first case (27 Apr)\\nDate labels and gridlines manually set to Sundays as well\")"},{"path":"epicurves.html","id":"dữ-liệu-tổng-hợp","chapter":"2 Đường cong dịch bệnh","heading":"Dữ liệu tổng hợp","text":"Thông thường, thay vì bắt đầu với bộ số liệu linelist, bạn có thể bắt đầu với số lượng tổng hợp từ các cơ sở y tế, quận, huyện, v.v. Bạn có thể tạo đường cong dịch bệnh với ggplot() nhưng code sẽ hơi khác một chút. Phần này sẽ tận dụng bộ dữ liệu count_data đã được nạp trước đó trong mục chuẩn bị dữ liệu. Bộ dữ liệu này là linelist được tổng hợp thành số lượng bệnh viện theo ngày. 50 hàng đầu tiên được hiển thị dưới đây.","code":""},{"path":"epicurves.html","id":"vẽ-biểu-đồ-dữ-liệu-đếm-hàng-ngày","chapter":"2 Đường cong dịch bệnh","heading":"Vẽ biểu đồ dữ liệu đếm hàng ngày","text":"Chúng ta có thể vẽ biểu đồ đường cong dịch bệnh từ dữ liệu đếm hàng ngày. Dưới đây là sự khác biệt trong đoạn code:Khi ánh xạ các yếu tố trong hàm aes(), hãy cụ thể y = bằng một cột đếm (trong trường hợp này, tên cột là n_cases)Khi ánh xạ các yếu tố trong hàm aes(), hãy cụ thể y = bằng một cột đếm (trong trường hợp này, tên cột là n_cases)Thêm đối số stat = \"identity\" trong geom_histogram(), giúp xác định rằng chiều cao cột phải là giá trị y =, không phải số hàng như mặc địnhThêm đối số stat = \"identity\" trong geom_histogram(), giúp xác định rằng chiều cao cột phải là giá trị y =, không phải số hàng như mặc địnhThêm đối số width = để tránh các đường trắng dọc giữa các cột. Đối với dữ liệu hàng ngày được đặt thành 1. Đối với dữ liệu đếm hàng tuần được đặt thành 7. Đối với dữ liệu đếm hàng tháng, các đường màu trắng là một vấn đề (mỗi tháng có số ngày khác nhau) - hãy xem xét chuyển đổi trục x của bạn thành cột phân loại (factor) theo thứ tự (tháng) và sử dụng geom_col().Thêm đối số width = để tránh các đường trắng dọc giữa các cột. Đối với dữ liệu hàng ngày được đặt thành 1. Đối với dữ liệu đếm hàng tuần được đặt thành 7. Đối với dữ liệu đếm hàng tháng, các đường màu trắng là một vấn đề (mỗi tháng có số ngày khác nhau) - hãy xem xét chuyển đổi trục x của bạn thành cột phân loại (factor) theo thứ tự (tháng) và sử dụng geom_col().","code":"\nggplot(data = count_data)+\n  geom_histogram(\n   mapping = aes(x = date_hospitalisation, y = n_cases),\n   stat = \"identity\",\n   width = 1)+                # for daily counts, set width = 1 to avoid white space between bars\n  labs(\n    x = \"Date of report\", \n    y = \"Number of cases\",\n    title = \"Daily case incidence, from daily count data\")"},{"path":"epicurves.html","id":"vẽ-biểu-đồ-dữ-liệu-đếm-hàng-tuần","chapter":"2 Đường cong dịch bệnh","heading":"Vẽ biểu đồ dữ liệu đếm hàng tuần","text":"Nếu dữ liệu của bạn đã là số lượng ca bệnh đếm theo tuần, chúng có thể trông giống như bộ dữ liệu này (được gọi là count_data_weekly):50 hàng đầu tiên của count_data_weekly được hiển thị bên dưới. Bạn có thể thấy rằng số lượng đếm đã được tổng hợp thành các tuần. Mỗi tuần được hiển thị theo ngày đầu tiên của tuần (mặc định là Thứ Hai).Bây giờ vẽ biểu đồ sao cho x = cột epiweek. Hãy nhớ thêm y = cột đếm khi ánh xạ trục và thêm stat = \"identity\" như đã giải thích ở trên.","code":"\nggplot(data = count_data_weekly)+\n  \n  geom_histogram(\n    mapping = aes(\n      x = epiweek,           # x-axis is epiweek (as class Date)\n      y = n_cases_weekly,    # y-axis height in the weekly case counts\n      group = hospital,      # we are grouping the bars and coloring by hospital\n      fill = hospital),\n    stat = \"identity\")+      # this is also required when plotting count data\n     \n  # labels for x-axis\n  scale_x_date(\n    date_breaks = \"2 months\",      # labels every 2 months \n    date_minor_breaks = \"1 month\", # gridlines every month\n    date_labels = '%b\\n%Y')+       #labeled by month with year below\n     \n  # Choose color palette (uses RColorBrewer package)\n  scale_fill_brewer(palette = \"Pastel2\")+ \n  \n  theme_minimal()+\n  \n  labs(\n    x = \"Week of onset\", \n    y = \"Weekly case incidence\",\n    fill = \"Hospital\",\n    title = \"Weekly case incidence, from aggregated count data by hospital\")"},{"path":"epicurves.html","id":"đường-trung-bình-động","chapter":"2 Đường cong dịch bệnh","heading":"Đường trung bình động","text":"Xem chương về Đường trung bình động để có mô tả chi tiết và một số tùy chọn. Dưới đây là một tùy chọn để tính toán đường trung bình động với package slider. Theo cách tiếp cận này, trung bình động được tính toán trong bộ dữ liệu trước khi vẽ biểu đồ:Tổng hợp dữ liệu thành số lượng nếu cần thiết (hàng ngày, hàng tuần, v.v.) (xem chương [Nhóm dữ liệu])Tạo một cột mới để giữ đường trung bình động, được tạo bằng hàm slide_index() từ package sliderVẽ đường trung bình động dưới dạng một geom_line() ở trên đỉnh (phía sau) histogram đường cong dịch bệnhTham khảo thêm tại vignette của package slider","code":"\n# load package\npacman::p_load(slider)  # slider used to calculate rolling averages\n\n# make dataset of daily counts and 7-day moving average\n#######################################################\nll_counts_7day <- linelist %>%    # begin with linelist\n  \n  ## count cases by date\n  count(date_onset, name = \"new_cases\") %>%   # name new column with counts as \"new_cases\"\n  drop_na(date_onset) %>%                     # remove cases with missing date_onset\n  \n  ## calculate the average number of cases in 7-day window\n  mutate(\n    avg_7day = slider::slide_index(    # create new column\n      new_cases,                       # calculate based on value in new_cases column\n      .i = date_onset,                 # index is date_onset col, so non-present dates are included in window \n      .f = ~mean(.x, na.rm = TRUE),    # function is mean() with missing values removed\n      .before = 6,                     # window is the day and 6-days before\n      .complete = FALSE),              # must be FALSE for unlist() to work in next step\n    avg_7day = unlist(avg_7day))       # convert class list to class numeric\n\n\n# plot\n######\nggplot(data = ll_counts_7day) +  # begin with new dataset defined above \n    geom_histogram(              # create epicurve histogram\n      mapping = aes(\n        x = date_onset,          # date column as x-axis\n        y = new_cases),          # height is number of daily new cases\n        stat = \"identity\",       # height is y value\n        fill=\"#92a8d1\",          # cool color for bars\n        colour = \"#92a8d1\",      # same color for bar border\n        )+ \n    geom_line(                   # make line for rolling average\n      mapping = aes(\n        x = date_onset,          # date column for x-axis\n        y = avg_7day,            # y-value set to rolling average column\n        lty = \"7-day \\nrolling avg\"), # name of line in legend\n      color=\"red\",               # color of line\n      size = 1) +                # width of line\n    scale_x_date(                # date scale\n      date_breaks = \"1 month\",\n      date_labels = '%d/%m',\n      expand = c(0,0)) +\n    scale_y_continuous(          # y-axis scale\n      expand = c(0,0),\n      limits = c(0, NA)) +       \n    labs(\n      x=\"\",\n      y =\"Number of confirmed cases\",\n      fill = \"Legend\")+ \n    theme_minimal()+\n    theme(legend.title = element_blank())  # removes title of legend"},{"path":"epicurves.html","id":"facetingchia-nhỏ-biểu-đồ","chapter":"2 Đường cong dịch bệnh","heading":"Faceting/chia nhỏ biểu đồ","text":"Như với các ggplots khác, bạn có thể tạo các biểu đồ được chia nhỏ (“nhiều biểu đồ con”). Như đã giải thích trong chương [Các tips với ggplot] trong cuốn sách này, bạn có thể sử dụng facet_wrap() hoặc facet_grid(). Ở đây chúng tôi sẽ minh họa bằng hàm facet_wrap(). Đối với đường cong dịch bệnh, sử dụng facet_wrap() thường dễ dàng hơn vì khả năng bạn thường chỉ cần chia nhỏ biểu đồ theo một biến.Cú pháp chung là facet_wrap(rows ~ cols), trong đó bên trái dấu ngã (~) là tên của biến sẽ được trải trên các “hàng” của biểu đồ chia nhỏ và ở bên phải dấu ngã là tên của biến sẽ được trải trên các “cột” của biểu đồ chia nhỏ. Đơn giản nhất, chỉ cần sử dụng một tên cột, ở bên phải dấu ngã: facet_wrap(~age_cat).Trục tự \nBạn sẽ cần phải quyết định xem tỷ lệ của các trục cho mỗi biểu đồ nhỏ là “cố định” với cùng một kích thước (mặc định) hay “tự ” (nghĩa là chúng sẽ thay đổi dựa trên dữ liệu của chúng). Thực hiện điều này với đối số scales = trong hàm facet_wrap() bằng cách chỉ định “free_x” hoặc “free_y” hoặc “free”.Số cột và hàng của các biểu đồ con\nĐiều này có thể xác định với ncol = và nrow = trong hàm facet_wrap().Thứ tự các biểu đồ con\nĐể thay đổi thứ tự xuất hiện, hãy thay đổi thứ tự cơ bản của các cấp của cột phân loại được sử dụng để tạo các biểu đồ con.Đinh dạng trục\nKích thước phông chữ và mặt biểu đồ, dải màu, v.v. có thể được sửa đổi thông qua theme() với các đối số như:strip.text = element_text() (kích thước, màu sắc, mặt, góc …)strip.text = element_text() (kích thước, màu sắc, mặt, góc …)strip.background = element_rect() (ví dụ: element_rect(fill = \"grey\"))strip.background = element_rect() (ví dụ: element_rect(fill = \"grey\"))strip.position = (vị trị “dưới”, “trên”, “trái”, hoặc “phải”)strip.position = (vị trị “dưới”, “trên”, “trái”, hoặc “phải”)Dải nhãn\nNhãn của các biểu đồ con có thể được sửa đổi thông qua “nhãn” của cột như một factor hoặc bằng cách sử dụng một “người dán nhãn - labeller”.Để tạo một labeller như thế, sử dụng hàm as_labeller() từ ggplot2. Sau đó, cung cấp labeller cho đối số labeller = của facet_wrap() như dưới đây.Một ví dụ về chia nhỏ biểu đồ - chia bằng cột age_cat.Xem link để biết thêm thông tin về labellers.","code":"\nmy_labels <- as_labeller(c(\n     \"0-4\"   = \"Ages 0-4\",\n     \"5-9\"   = \"Ages 5-9\",\n     \"10-14\" = \"Ages 10-14\",\n     \"15-19\" = \"Ages 15-19\",\n     \"20-29\" = \"Ages 20-29\",\n     \"30-49\" = \"Ages 30-49\",\n     \"50-69\" = \"Ages 50-69\",\n     \"70+\"   = \"Over age 70\"))\n# make plot\n###########\nggplot(central_data) + \n  \n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),    # arguments inside aes() apply by group\n      \n    color = \"black\",      # arguments outside aes() apply to all data\n        \n    # histogram breaks\n    breaks = weekly_breaks_central)+  # pre-defined date vector (see earlier in this page)\n                      \n  # The labels on the x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    date_labels       = \"%b\\n'%y\")+     # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+                       # removes excess y-axis space between bottom of bars and the labels\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"grey\"))+         # axis titles in bold\n  \n  # create facets\n  facet_wrap(\n    ~age_cat,\n    ncol = 4,\n    strip.position = \"top\",\n    labeller = my_labels)+             \n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases, by age category\",\n    subtitle = \"Subtitle\",\n    fill     = \"Age category\",                                      # provide new title for legend\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))"},{"path":"epicurves.html","id":"tổng-vụ-dịch-trong-nền-của-biểu-đồ-con","chapter":"2 Đường cong dịch bệnh","heading":"Tổng vụ dịch trong nền của biểu đồ con","text":"Để hiển thị tổng vụ dịch trong nền của mỗi biểu đồ con, hãy thêm hàm gghighlight() với dấu ngoặc đơn trống vào ggplot. Hàm này thuộc package gghighlight. Lưu ý rằng trục y tối đa trong tất cả các biểu đồ con hiện dựa vào đỉnh của toàn bộ vụ dịch. Có nhiều ví dụ hơn về package này trong chương [Các tips với ggplot].","code":"\nggplot(central_data) + \n  \n  # epicurves by group\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),  # arguments inside aes() apply by group\n    \n    color = \"black\",    # arguments outside aes() apply to all data\n    \n    # histogram breaks\n    breaks = weekly_breaks_central)+     # pre-defined date vector (see top of ggplot section)                \n  \n  # add grey epidemic in background to each facet\n  gghighlight::gghighlight()+\n  \n  # labels on x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    date_labels       = \"%b\\n'%y\")+     # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space below 0\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"white\"))+        # axis titles in bold\n  \n  # create facets\n  facet_wrap(\n    ~age_cat,                          # each plot is one value of age_cat\n    ncol = 4,                          # number of columns\n    strip.position = \"top\",            # position of the facet title/strip\n    labeller = my_labels)+             # labeller defines above\n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases, by age category\",\n    subtitle = \"Subtitle\",\n    fill     = \"Age category\",                                      # provide new title for legend\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))"},{"path":"epicurves.html","id":"dữ-liệu-một-biểu-đồ-con","chapter":"2 Đường cong dịch bệnh","heading":"Dữ liệu một biểu đồ con","text":"Nếu bạn muốn có một hộp biểu đồ con chứa tất cả dữ liệu, hãy sao chép toàn bộ dữ liệu và coi các bản sao như một giá trị cho các biểu đồ con. Hàm “trợ giúp” CreateAllFacet() bên dưới có thể hỗ trợ việc này (nhờ bài đăng trên blog này). Khi nó được chạy, số hàng tăng gấp đôi và sẽ có một cột mới được gọi là facet, trong đó các hàng được sao chép sẽ có giá trị “tất cả” và các hàng ban đầu có giá trị ban đầu của cột phân chia. Bây giờ bạn chỉ cần phân chia cột facet .Dưới đây là hàm trợ giúp. Chạy code này và nó sẽ luôn sẵn sàng để bạn sử dụng.Bây giờ hãy áp dụng hàm trợ giúp cho bộ dữ liệu, trên cột age_cat:Những thay đổi đáng chú ý đối với lệnh ggplot() là:Dữ liệu được sử dụng bây giờ là central_data2 (nhân đôi các hàng, với cột mới là “facet”)Dữ liệu được sử dụng bây giờ là central_data2 (nhân đôi các hàng, với cột mới là “facet”)Labeller sẽ cần được cập nhật, nếu được sử dụngLabeller sẽ cần được cập nhật, nếu được sử dụngTùy chọn: để có các biểu đồ con xếp chồng lên nhau theo chiều dọc: cột chia được chuyển sang các hàng bên cạnh của phương trình và ở bên phải được thay thế bằng “.” (facet_wrap(facet~.)), và ncol = 1. Bạn cũng có thể cần điều chỉnh chiều rộng và chiều cao của ảnh biểu đồ đã lưu dưới dạng png (xem ggsave() trong chương [Các tips với ggplot]).Tùy chọn: để có các biểu đồ con xếp chồng lên nhau theo chiều dọc: cột chia được chuyển sang các hàng bên cạnh của phương trình và ở bên phải được thay thế bằng “.” (facet_wrap(facet~.)), và ncol = 1. Bạn cũng có thể cần điều chỉnh chiều rộng và chiều cao của ảnh biểu đồ đã lưu dưới dạng png (xem ggsave() trong chương [Các tips với ggplot]).","code":"\n# Define helper function\nCreateAllFacet <- function(df, col){\n     df$facet <- df[[col]]\n     temp <- df\n     temp$facet <- \"all\"\n     merged <-rbind(temp, df)\n     \n     # ensure the facet value is a factor\n     merged[[col]] <- as.factor(merged[[col]])\n     \n     return(merged)\n}\n# Create dataset that is duplicated and with new column \"facet\" to show \"all\" age categories as another facet level\ncentral_data2 <- CreateAllFacet(central_data, col = \"age_cat\") %>%\n  \n  # set factor levels\n  mutate(facet = fct_relevel(facet, \"all\", \"0-4\", \"5-9\",\n                             \"10-14\", \"15-19\", \"20-29\",\n                             \"30-49\", \"50-69\", \"70+\"))## Warning: Unknown levels in `f`: 70+\n# check levels\ntable(central_data2$facet, useNA = \"always\")## \n##   all   0-4   5-9 10-14 15-19 20-29 30-49 50-69  <NA> \n##   454    84    84    82    58    73    57     7     9\nggplot(central_data2) + \n  \n  # actual epicurves by group\n  geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = age_cat,\n          fill = age_cat),  # arguments inside aes() apply by group\n        color = \"black\",    # arguments outside aes() apply to all data\n        \n        # histogram breaks\n        breaks = weekly_breaks_central)+    # pre-defined date vector (see top of ggplot section)\n                     \n  # Labels on x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    date_labels       = \"%b\\n'%y\")+     # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space between bottom of bars and the labels\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\")+               \n  \n  # create facets\n  facet_wrap(facet~. ,                            # each plot is one value of facet\n             ncol = 1)+            \n\n  # labels\n  labs(title    = \"Weekly incidence of cases, by age category\",\n       subtitle = \"Subtitle\",\n       fill     = \"Age category\",                                      # provide new title for legend\n       x        = \"Week of symptom onset\",\n       y        = \"Weekly incident cases reported\",\n       caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))"},{"path":"epicurves.html","id":"dữ-liệu-dự-kiến","chapter":"2 Đường cong dịch bệnh","heading":"2.4 Dữ liệu dự kiến","text":"Dữ liệu gần đây nhất được biểu thị trong đường cong dịch tễ nên được đánh dấu là dự kiến hoặc có thể báo cáo chậm trễ. Điều này có thể được thực hiện bằng cách thêm một đường thẳng đứng và/hoặc hình chữ nhật trong một số ngày cụ thể. Đây là hai tùy chọn:Sử dụng annotate():\nĐể sử dụng dạng đường annotate(geom = \"segment\"). Cung cấp x, xend, y, và yend. Hiệu chỉnh kích thước, kiểu dòng (lty), và màu.\nĐể sử dụng dạng hình chữ nhật annotate(geom = \"rect\"). Cung cấp xmin/xmax/ymin/ymax. Hiệu chỉnh màu và hệ số alpha.\nSử dụng annotate():Để sử dụng dạng đường annotate(geom = \"segment\"). Cung cấp x, xend, y, và yend. Hiệu chỉnh kích thước, kiểu dòng (lty), và màu.Để sử dụng dạng hình chữ nhật annotate(geom = \"rect\"). Cung cấp xmin/xmax/ymin/ymax. Hiệu chỉnh màu và hệ số alpha.Nhóm dữ liệu theo trạng thái tạm thời và tô màu các cột đó theo cách khác nhauNhóm dữ liệu theo trạng thái tạm thời và tô màu các cột đó theo cách khác nhauTHẬN TRỌNG: Bạn có thể thử hàm geom_rect() để vẽ hình chữ nhật, nhưng việc điều chỉnh độ trong suốt không khả thi trong bối cảnh cảnh bộ số liệu linelist. Hàm này sẽ phủ lên một hình chữ nhật cho mỗi hàng/quan sát!. Sử dụng hệ số alpha rất thấp (ví dụ: 0.01) hoặc một cách tiếp cận khác.","code":""},{"path":"epicurves.html","id":"sử-dụng-annotate","chapter":"2 Đường cong dịch bệnh","heading":"Sử dụng annotate()","text":"Trong annotate(geom = \"rect\"), đối số xmin và xmax cần được định dạng phân lớp ngàyLưu ý rằng vì những dữ liệu này được tổng hợp thành các cột hàng tuần và cột cuối cùng kéo dài đến Thứ Hai sau điểm dữ liệu cuối cùng, vùng được tô bóng có thể bao gồm 4 tuầnĐây là một ví dụ trực tuyến về annotate()Đường thẳng đứng màu đen có thể tạo ra với code bên dưới, nhưng sử dụng geom_vline(), bạn sẽ mất khả năng kiểm soát chiều cao:","code":"\nggplot(central_data) + \n  \n  # histogram\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    breaks = weekly_breaks_central,   # pre-defined date vector - see top of ggplot section\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") +\n\n  # scales\n  scale_y_continuous(expand = c(0,0))+\n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"1 month\",           # 1st of month\n    date_minor_breaks = \"1 month\",     # 1st of month\n    date_labels = \"%b\\n'%y\")+          # label format\n  \n  # labels and theme\n  labs(\n    title = \"Using annotate()\\nRectangle and line showing that data from last 21-days are tentative\",\n    x = \"Week of symptom onset\",\n    y = \"Weekly case indicence\")+ \n  theme_minimal()+\n  \n  # add semi-transparent red rectangle to tentative data\n  annotate(\n    \"rect\",\n    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # note must be wrapped in as.Date()\n    xmax  = as.Date(Inf),                                          # note must be wrapped in as.Date()\n    ymin  = 0,\n    ymax  = Inf,\n    alpha = 0.2,          # alpha easy and intuitive to adjust using annotate()\n    fill  = \"red\")+\n  \n  # add black vertical line on top of other layers\n  annotate(\n    \"segment\",\n    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 days before last data\n    xend  = max(central_data$date_onset, na.rm = T) - 21, \n    y     = 0,         # line begins at y = 0\n    yend  = Inf,       # line to top of plot\n    size  = 2,         # line size\n    color = \"black\",\n    lty   = \"solid\")+   # linetype e.g. \"solid\", \"dashed\"\n\n  # add text in rectangle\n  annotate(\n    \"text\",\n    x = max(central_data$date_onset, na.rm = T) - 15,\n    y = 15,\n    label = \"Subject to reporting delays\",\n    angle = 90)\ngeom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,\n           size = 2,\n           color = \"black\")"},{"path":"epicurves.html","id":"màu-cột","chapter":"2 Đường cong dịch bệnh","heading":"Màu cột","text":"Một cách tiếp cận thay thế có thể là điều chỉnh màu sắc hoặc cách hiển thị của chính các cột dữ liệu dự kiến. Bạn có thể tạo một cột mới trong giai đoạn chuẩn bị dữ liệu và sử dụng cột đó để nhóm dữ liệu, sao cho aes(fill = ) của dữ liệu tạm thời có thể có màu hoặc hệ số alpha khác với các cột khác.","code":"\n# add column\n############\nplot_data <- central_data %>% \n  mutate(tentative = case_when(\n    date_onset >= max(date_onset, na.rm=T) - 7 ~ \"Tentative\", # tenative if in last 7 days\n    TRUE                                       ~ \"Reliable\")) # all else reliable\n\n# plot\n######\nggplot(plot_data, aes(x = date_onset, fill = tentative)) + \n  \n  # histogram\n  geom_histogram(\n    breaks = weekly_breaks_central,   # pre-defined data vector, see top of ggplot page\n    color = \"black\") +\n\n  # scales\n  scale_y_continuous(expand = c(0,0))+\n  scale_fill_manual(values = c(\"lightblue\", \"grey\"))+\n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"3 weeks\",           # Monday every 3 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    date_labels = \"%d\\n%b\\n'%y\")+      # label format\n  \n  # labels and theme\n  labs(title = \"Show days that are tentative reporting\",\n    subtitle = \"\")+ \n  theme_minimal()+\n  theme(legend.title = element_blank())                 # remove title of legend"},{"path":"epicurves.html","id":"nhãn-ngày-nhiều-cấp-độ","chapter":"2 Đường cong dịch bệnh","heading":"2.5 Nhãn ngày nhiều cấp độ","text":"Nếu bạn muốn phân nhiều cấp nhãn ngày (ví dụ: tháng và năm) mà không sao chép các cấp nhãn cấp độ thấp hơn, hãy xem xét một trong các cách tiếp cận bên dưới:Hãy nhớ rằng - bạn có thể sử dụng các công cụ như \\n trong các đối số date_labels hoặc labels để đặt các phần của mỗi nhãn trên một dòng mới bên dưới. Tuy nhiên, đoạn code dưới đây giúp bạn thực hiện nhiều năm hoặc tháng (ví dụ) ở dòng thấp hơn và chỉ một lần. Một số lưu ý về code bên dưới:Số lượng ca bệnh được tổng hợp thành các tuần vì lý thẩm mỹ. Xem chương Đường cong dịch bệnh (tab dữ liệu tổng hợp) để biết chi tiết.Một miền geom_area() được sử dụng thay vì một histogram, vì phương pháp tiếp cận chia biểu đồ dưới đây không hoạt động tốt với histogram.Tổng hợp dữ đếm hàng tuầnVẽ biểu đồCác kỹ thuật trên được điều chỉnh từ đây và bài đăng này trên stackoverflow.com.","code":"\n# Create dataset of case counts by week\n#######################################\ncentral_weekly <- linelist %>%\n  filter(hospital == \"Central Hospital\") %>%   # filter linelist\n  mutate(week = lubridate::floor_date(date_onset, unit = \"weeks\")) %>%  \n  count(week) %>%                              # summarize weekly case counts\n  drop_na(week) %>%                            # remove cases with missing onset_date\n  complete(                                    # fill-in all weeks with no cases reported\n    week = seq.Date(\n      from = min(week),   \n      to   = max(week),\n      by   = \"week\"),\n    fill = list(n = 0))                        # convert new NA values to 0 counts\n# plot with box border on year\n##############################\nggplot(central_weekly) +\n  geom_area(aes(x = week, y = n),    # make line, specify x and y\n            stat = \"identity\") +             # because line height is count number\n  scale_x_date(date_labels=\"%b\",             # date label format show month \n               date_breaks=\"month\",          # date labels on 1st of each month\n               expand=c(0,0)) +              # remove excess space on each end\n  scale_y_continuous(\n    expand  = c(0,0))+                       # remove excess space below x-axis\n  facet_grid(~lubridate::year(week), # facet on year (of Date class column)\n             space=\"free_x\",                \n             scales=\"free_x\",                # x-axes adapt to data range (not \"fixed\")\n             switch=\"x\") +                   # facet labels (year) on bottom\n  theme_bw() +\n  theme(strip.placement = \"outside\",         # facet labels placement\n        strip.background = element_rect(fill = NA, # facet labels no fill grey border\n                                        colour = \"grey50\"),\n        panel.spacing = unit(0, \"cm\"))+      # no space between facet panels\n  labs(title = \"Nested year labels, grey label border\")\n# plot with no box border on year\n#################################\nggplot(central_weekly,\n       aes(x = week, y = n)) +              # establish x and y for entire plot\n  geom_line(stat = \"identity\",              # make line, line height is count number\n            color = \"#69b3a2\") +            # line color\n  geom_point(size=1, color=\"#69b3a2\") +     # make points at the weekly data points\n  geom_area(fill = \"#69b3a2\",               # fill area below line\n            alpha = 0.4)+                   # fill transparency\n  scale_x_date(date_labels=\"%b\",            # date label format show month \n               date_breaks=\"month\",         # date labels on 1st of each month\n               expand=c(0,0)) +             # remove excess space\n  scale_y_continuous(\n    expand  = c(0,0))+                      # remove excess space below x-axis\n  facet_grid(~lubridate::year(week),        # facet on year (of Date class column)\n             space=\"free_x\",                \n             scales=\"free_x\",               # x-axes adapt to data range (not \"fixed\")\n             switch=\"x\") +                  # facet labels (year) on bottom\n  theme_bw() +\n  theme(strip.placement = \"outside\",                     # facet label placement\n          strip.background = element_blank(),            # no facet lable background\n          panel.grid.minor.x = element_blank(),          \n          panel.border = element_rect(colour=\"grey40\"),  # grey border to facet PANEL\n          panel.spacing=unit(0,\"cm\"))+                   # No space between facet panels\n  labs(title = \"Nested year labels - points, shaded, no label border\")"},{"path":"epicurves.html","id":"trục-kép","chapter":"2 Đường cong dịch bệnh","heading":"2.6 Trục kép","text":"Mặc dù có những cuộc thảo luận gay gắt về tính hợp lệ của trục kép trong cộng đồng về trực quan hóa dữ liệu, nhiều chuyên gia dịch tễ vẫn muốn nhìn nhận biểu đồ đường cong dịch bệnh hoặc biểu đồ tương tự với phần trăm trên trục thứ hai. Điều này được thảo luận nhiều hơn trong chương [Các tips với ggplot], nhưng một ví dụ sử dụng phương pháp cowplot được trình bày bên dưới:Hai biểu đồ riêng biệt được tạo, và sau đó được kết hợp với package cowplot.Các biểu đồ phải có chính xác cùng trục x (đã đặt giới hạn), nếu không dữ liệu và nhãn sẽ không được căn chỉnh phù hợpMỗi biểu đồ sử dụng theme_cowplot() và một biểu đồ có trục y được di chuyển sang phía bên phải của biểu đồBây giờ sử dụng cowplot để chồng lên hai biểu đồ. Sự chú ý đã được tập trung vào việc căn chỉnh trục x, cạnh của trục y và việc sử dụng theme_cowplot().","code":"\n#load package\npacman::p_load(cowplot)\n\n# Make first plot of epicurve histogram\n#######################################\nplot_cases <- linelist %>% \n  \n  # plot cases per week\n  ggplot()+\n  \n  # create histogram  \n  geom_histogram(\n    \n    mapping = aes(x = date_onset),\n    \n    # bin breaks every week beginning monday before first case, going to monday after last case\n    breaks = weekly_breaks_all)+  # pre-defined vector of weekly dates (see top of ggplot section)\n        \n  # specify beginning and end of date axis to align with other plot\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram\n  \n  # labels\n  labs(\n      y = \"Daily cases\",\n      x = \"Date of symptom onset\"\n    )+\n  theme_cowplot()\n\n\n# make second plot of percent died per week\n###########################################\nplot_deaths <- linelist %>%                        # begin with linelist\n  group_by(week = floor_date(date_onset, \"week\")) %>%  # create week column\n  \n  # summarise to get weekly percent of cases who died\n  summarise(n_cases = n(),\n            died = sum(outcome == \"Death\", na.rm=T),\n            pct_died = 100*died/n_cases) %>% \n  \n  # begin plot\n  ggplot()+\n  \n  # line of weekly percent who died\n  geom_line(                                # create line of percent died\n    mapping = aes(x = week, y = pct_died),  # specify y-height as pct_died column\n    stat = \"identity\",                      # set line height to the value in pct_death column, not the number of rows (which is default)\n    size = 2,\n    color = \"black\")+\n  \n  # Same date-axis limits as the other plot - perfect alignment\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram\n  \n  \n  # y-axis adjustments\n  scale_y_continuous(                # adjust y-axis\n    breaks = seq(0,100, 10),         # set break intervals of percent axis\n    limits = c(0, 100),              # set extent of percent axis\n    position = \"right\")+             # move percent axis to the right\n  \n  # Y-axis label, no x-axis label\n  labs(x = \"\",\n       y = \"Percent deceased\")+      # percent axis label\n  \n  theme_cowplot()                   # add this to make the two plots merge together nicely\naligned_plots <- cowplot::align_plots(plot_cases, plot_deaths, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])"},{"path":"epicurves.html","id":"số-mới-mắc-tích-lũy-1","chapter":"2 Đường cong dịch bệnh","heading":"2.7 Số mới mắc tích lũy","text":"Lưu ý: Nếu sử dụng incidence2, hãy xem chương về cách bạn có thể tính số mới mắc tích lũy bằng một hàm đơn giản. Chương này sẽ đề cập đến cách tính số mới mắc tích lũy và vẽ biểu đồ bằng ggplot().Nếu bắt đầu bằng bộ số liệu linelist, hãy tạo một cột mới chứa số ca bệnh tích lũy mỗi ngày trong đợt bùng phát bằng cách sử dụng cumsum() từ base R:10 hàng đầu tiên được hiển thị bên dưới:Sau đó, cột tích lũy này có thể được vẽ dựa trên date_onset, sử dụng geom_line():Nó cũng có thể được phủ đè lên đường cong dịch bệnh, với trục kép bằng cách sử dụng phương pháp cowplot được mô tả ở trên và trong chương [Các tips với ggplot]:Bây giờ sử dụng cowplot để chồng lên hai biểu đồ. Sự chú ý đã được tập trung vào việc căn chỉnh trục x, cạnh của trục y và việc sử dụng theme_cowplot().","code":"\ncumulative_case_counts <- linelist %>% \n  count(date_onset) %>%                # count of rows per day (returned in column \"n\")   \n  mutate(                         \n    cumulative_cases = cumsum(n)       # new column of the cumulative number of rows at each date\n    )\nplot_cumulative <- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")\n\nplot_cumulative\n#load package\npacman::p_load(cowplot)\n\n# Make first plot of epicurve histogram\nplot_cases <- ggplot()+\n  geom_histogram(          \n    data = linelist,\n    aes(x = date_onset),\n    binwidth = 1)+\n  labs(\n    y = \"Daily cases\",\n    x = \"Date of symptom onset\"\n  )+\n  theme_cowplot()\n\n# make second plot of cumulative cases line\nplot_cumulative <- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")+\n  scale_y_continuous(\n    position = \"right\")+\n  labs(x = \"\",\n       y = \"Cumulative cases\")+\n  theme_cowplot()+\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.title.x = element_blank(),\n    axis.ticks = element_blank())\naligned_plots <- cowplot::align_plots(plot_cases, plot_cumulative, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])"},{"path":"epicurves.html","id":"nguồn-tham-khảo","chapter":"2 Đường cong dịch bệnh","heading":"2.8 Nguồn tham khảo","text":"","code":""}]
